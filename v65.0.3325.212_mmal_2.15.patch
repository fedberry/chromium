Index: chromium-browser-65.0.3325.181/base/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/base/BUILD.gn
+++ chromium-browser-65.0.3325.181/base/BUILD.gn
@@ -288,6 +288,8 @@ jumbo_component("base") {
     "debug/close_handle_hook_win.h",
     "debug/crash_logging.cc",
     "debug/crash_logging.h",
+    "debug/ctime.cc",
+    "debug/ctime.h",
     "debug/debugger.cc",
     "debug/debugger.h",
     "debug/debugger_posix.cc",
Index: chromium-browser-65.0.3325.181/base/allocator/partition_allocator/spin_lock.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/base/allocator/partition_allocator/spin_lock.cc
+++ chromium-browser-65.0.3325.181/base/allocator/partition_allocator/spin_lock.cc
@@ -29,7 +29,13 @@
 #if defined(ARCH_CPU_X86_64) || defined(ARCH_CPU_X86)
 #define YIELD_PROCESSOR __asm__ __volatile__("pause")
 #elif (defined(ARCH_CPU_ARMEL) && __ARM_ARCH >= 6) || defined(ARCH_CPU_ARM64)
+#if __ARM_ARCH >= 7 ||\
+  defined(__ARM_ARCH_6KZ__) || defined(__ARM_ARCH_6ZK__) ||\
+  defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6K__)
 #define YIELD_PROCESSOR __asm__ __volatile__("yield")
+#else
+#define YIELD_PROCESSOR __asm__ __volatile__("nop")
+#endif
 #elif defined(ARCH_CPU_MIPSEL)
 // The MIPS32 docs state that the PAUSE instruction is a no-op on older
 // architectures (first added in MIPS32r2). To avoid assembler errors when
Index: chromium-browser-65.0.3325.181/base/debug/ctime.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/base/debug/ctime.cc
@@ -0,0 +1,136 @@
+#include "base/debug/ctime.h"
+
+#include <stdio.h>
+#include <time.h>
+
+namespace base {
+
+static uint64_t ns_time()
+{
+  struct timespec tp;
+  clock_gettime(CLOCK_MONOTONIC, &tp);
+  return (int64_t)tp.tv_nsec + (int64_t)tp.tv_sec * (int64_t)1000000000;
+}
+
+CTimeBase::CTimeBase() :
+  start(ns_time())
+{
+}
+
+CTimeBase::~CTimeBase()
+{
+}
+
+uint64_t
+CTimeBase::elapsed_ns() const
+{
+  return ns_time() - start;
+}
+
+unsigned int
+CTimeBase::elapsed_ms() const
+{
+  return (unsigned int)((elapsed_ns() + 500000) / (uint64_t)1000000);
+}
+
+CTime::CTime(const char * const name, const bool nz_only) :
+  name(name),
+  nz_only(nz_only)
+{
+  if (!nz_only)
+  {
+    fprintf(stderr, "<<< %s\n", name);
+  }
+}
+
+void
+CTime::trace(const char * const str)
+{
+  const unsigned int ms = elapsed_ms();
+  if (ms != 0 || !nz_only)
+    fprintf(stderr, "--- %s:%s (%dms)\n", name, str, ms);
+}
+
+CTime:: ~CTime()
+{
+  const unsigned int ms = elapsed_ms();
+  if (ms != 0 || !nz_only)
+    fprintf(stderr, ">>> %s (%dms)\n", name, ms);
+}
+
+AccTimeBase::AccTimeBase() :
+  a(0),
+  n(0)
+{
+}
+
+AccTimeBase::~AccTimeBase()
+{
+}
+
+void
+AccTimeBase::add(const uint64_t d)
+{
+    ++n;
+    a += d;
+}
+
+
+AccTime:: AccTime(const char name[]) :
+    name(name),
+    last_count(0),
+    last_acc(0)
+{
+}
+
+AccTime::~AccTime()
+{
+}
+
+void
+AccTime::add(const uint64_t d)
+{
+  const uint64_t now = ns_time();
+
+  if (count() == 0)
+  {
+    start = now;
+    last_output = now;
+  }
+
+  AccTimeBase::add(d);
+
+  if (now - last_output >= 1000000000)
+  {
+    const int c = count();
+    const uint64_t acc = acc_ns();
+
+    fprintf(stderr, "%s: n=%d, cpu=%u ms/s\n", name, c - last_count,
+        (unsigned int)((acc - last_acc) / ((now - last_output) / (uint64_t)1000)));
+
+    last_acc = acc;
+    last_count = c;
+    last_output = now;
+  }
+}
+
+ATime::ATime(AccTimeBase& acc) : acc(acc) {}
+
+ATime::~ATime()
+{
+  acc.add(elapsed_ns());
+}
+
+#if 0
+#define CTIME_FN CTime _x_(__func__)
+#define CTIME_NZ_FN CTime _x_(__func__, true)
+#define CTIME_TRACE(s) _x_.trace(s)
+#else
+#define CTIME_FN
+#define CTIME_NZ_FN
+#define CTIME_TRACE(s)
+#endif
+
+}
+
+
Index: chromium-browser-65.0.3325.181/base/debug/ctime.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/base/debug/ctime.h
@@ -0,0 +1,90 @@
+#include <stdint.h>
+
+#include "base/base_export.h"
+
+namespace base {
+
+class BASE_EXPORT CTimeBase
+{
+  const uint64_t start;
+
+public:
+  CTimeBase();
+  virtual ~CTimeBase();
+  uint64_t elapsed_ns() const;
+  unsigned int elapsed_ms() const;
+};
+
+class BASE_EXPORT CTime : public CTimeBase
+{
+  const char * name;
+  bool nz_only;
+
+public:
+  CTime(const char * const name, const bool nz_only = false);
+  ~CTime() override;
+  void trace(const char * const str);
+};
+
+class BASE_EXPORT AccTimeBase
+{
+  uint64_t a;
+  int n;
+
+public:
+  AccTimeBase();
+  virtual ~AccTimeBase();
+  inline int count() const
+  {
+    return n;
+  }
+
+  virtual void add(const uint64_t d);
+
+  inline unsigned int acc_ms() const
+  {
+    return (unsigned int)((a + 500000) / 1000000);
+  }
+
+  inline uint64_t acc_ns() const
+  {
+    return a;
+  }
+};
+
+class BASE_EXPORT AccTime : public AccTimeBase
+{
+  const char * const name;
+  uint64_t start;
+  uint64_t last_output;
+  int last_count;
+  uint64_t last_acc;
+
+public:
+  AccTime(const char name[]);
+  ~AccTime() override;
+
+  void add(const uint64_t d) override;
+};
+
+class BASE_EXPORT ATime : public CTimeBase
+{
+  AccTimeBase& acc;
+
+public:
+  ATime(AccTimeBase& acc);
+  ~ATime() override;
+};
+
+#if 0
+#define CTIME_FN CTime _x_(__func__)
+#define CTIME_NZ_FN CTime _x_(__func__, true)
+#define CTIME_TRACE(s) _x_.trace(s)
+#else
+#define CTIME_FN
+#define CTIME_NZ_FN
+#define CTIME_TRACE(s)
+#endif
+
+}
+
Index: chromium-browser-65.0.3325.181/base/files/file_enumerator_posix.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/base/files/file_enumerator_posix.cc
+++ chromium-browser-65.0.3325.181/base/files/file_enumerator_posix.cc
@@ -14,6 +14,8 @@
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
 
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+
 namespace base {
 namespace {
 
Index: chromium-browser-65.0.3325.181/base/process/process_metrics_posix.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/base/process/process_metrics_posix.cc
+++ chromium-browser-65.0.3325.181/base/process/process_metrics_posix.cc
@@ -11,6 +11,8 @@
 #include <sys/time.h>
 #include <unistd.h>
 
+#include <sys/syscall.h>
+
 #include "base/logging.h"
 #include "build/build_config.h"
 
@@ -51,6 +53,27 @@ static const rlim_t kSystemDefaultMaxFds
 static const rlim_t kSystemDefaultMaxFds = 8192;
 #endif
 
+// On arm we end up using prlimit64 when getrlimit is called
+// prlimit64 is disallowed by the sandbox due to some
+// ChromeOS bug so actually use ugetrlimit
+#if defined(__arm__)
+#undef getrlimit
+#define getrlimit real_ugetrlimit
+
+static int real_ugetrlimit(const int limit, struct rlimit * const rlimit)
+{
+  int rv;
+  struct {
+    uint32_t rlim_cur;
+    uint32_t rlim_max;
+  } urlimit = {0,0};
+  rv = syscall(__NR_ugetrlimit, limit, &urlimit);
+  rlimit->rlim_cur = urlimit.rlim_cur;
+  rlimit->rlim_max = urlimit.rlim_max;
+  return rv;
+}
+#endif
+
 size_t GetMaxFds() {
   rlim_t max_fds;
   struct rlimit nofile;
Index: chromium-browser-65.0.3325.181/build/.gitignore
===================================================================
--- chromium-browser-65.0.3325.181.orig/build/.gitignore
+++ chromium-browser-65.0.3325.181/build/.gitignore
@@ -14,6 +14,7 @@
 /util/LASTCHANGE*
 /util/support
 /x64/
+/linux/raspian_*-sysroot/
 /linux/debian_*-sysroot/
 /linux/ubuntu_*-sysroot/
 /ios_files
Index: chromium-browser-65.0.3325.181/build/config/compiler/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/build/config/compiler/BUILD.gn
+++ chromium-browser-65.0.3325.181/build/config/compiler/BUILD.gn
@@ -2022,6 +2022,11 @@ config("default_symbols") {
   }
 }
 
+# Tweak arch
+config("force_march_armv7") {
+  cflags = [ "-march=armv7-a" ]
+}
+
 if (is_ios || is_mac) {
   # On Mac and iOS, this enables support for ARC (automatic ref-counting).
   # See http://clang.llvm.org/docs/AutomaticReferenceCounting.html.
Index: chromium-browser-65.0.3325.181/build/config/linux/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/build/config/linux/BUILD.gn
+++ chromium-browser-65.0.3325.181/build/config/linux/BUILD.gn
@@ -32,6 +32,8 @@ config("x11") {
     "X11",
     "X11-xcb",
     "xcb",
+#    "xcb-image",
+    "xcb-shm",
     "Xcomposite",
     "Xcursor",
     "Xdamage",
@@ -41,6 +43,10 @@ config("x11") {
     "Xrender",
     "Xtst",
   ]
+  if (current_cpu == "arm") {
+     libs += [ "xcb-image" ]
+  }
+
 }
 
 config("xcomposite") {
Index: chromium-browser-65.0.3325.181/build/secondary/third_party/libjpeg_turbo/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/build/secondary/third_party/libjpeg_turbo/BUILD.gn
+++ chromium-browser-65.0.3325.181/build/secondary/third_party/libjpeg_turbo/BUILD.gn
@@ -99,6 +99,25 @@ if (current_cpu == "x86" || current_cpu
   }
 }
 
+if (current_cpu == "arm") {
+  source_set("simd_arm_neon") {
+    sources = [
+      "simd/jsimd_arm_neon.S",
+    ]
+    cflags = [
+      "-mfpu=neon",
+    ]
+    visibility = [ ":simd" ]
+    configs -= [ "//build/config/compiler:chromium_code",
+      "//build/config/compiler:compiler_arm_fpu",
+    ]
+    configs += [
+      "//build/config/compiler:force_march_armv7",
+    ]
+  }
+}
+
+
 static_library("simd") {
   if (current_cpu == "x86") {
     deps = [
@@ -114,11 +133,15 @@ static_library("simd") {
     sources = [
       "simd/jsimd_x86_64.c",
     ]
-  } else if (current_cpu == "arm" && arm_version >= 7 &&
+  } else if (current_cpu == "arm" && arm_version >= 6 &&
              (arm_use_neon || arm_optionally_use_neon)) {
+    deps = [
+      ":simd_arm_neon",
+    ]
     sources = [
       "simd/jsimd_arm.c",
-      "simd/jsimd_arm_neon.S",
+# Included by dep above
+#      "simd/jsimd_arm_neon.S",
     ]
   } else if (current_cpu == "arm64") {
     sources = [
Index: chromium-browser-65.0.3325.181/cc/ipc/cc_param_traits_macros.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/ipc/cc_param_traits_macros.h
+++ chromium-browser-65.0.3325.181/cc/ipc/cc_param_traits_macros.h
@@ -144,6 +144,7 @@ IPC_STRUCT_TRAITS_BEGIN(viz::Transferabl
   IPC_STRUCT_TRAITS_MEMBER(format)
   IPC_STRUCT_TRAITS_MEMBER(buffer_format)
   IPC_STRUCT_TRAITS_MEMBER(filter)
+  IPC_STRUCT_TRAITS_MEMBER(stride)
   IPC_STRUCT_TRAITS_MEMBER(size)
   IPC_STRUCT_TRAITS_MEMBER(mailbox_holder)
   IPC_STRUCT_TRAITS_MEMBER(read_lock_fences_enabled)
Index: chromium-browser-65.0.3325.181/cc/layers/video_layer_impl.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/layers/video_layer_impl.cc
+++ chromium-browser-65.0.3325.181/cc/layers/video_layer_impl.cc
@@ -106,6 +106,14 @@ bool VideoLayerImpl::WillDraw(DrawMode d
         layer_tree_impl()->resource_provider(),
         layer_tree_impl()->settings().use_stream_video_draw_quad));
   }
+
+  // (Pi) nasty kludge to pass size info back to decode
+  if (!frame_->mmal_resize_cb_.is_null()) {
+//    LOG(ERROR) << "vis:" << visible_layer_rect().ToString() << ", clip:" << clip_rect().ToString() <<
+//      ", drawable:" << drawable_content_rect().ToString() << ", bounds:" << bounds().ToString();
+    frame_->mmal_resize_cb_.Run(bounds());
+  }
+
   updater_->ObtainFrameResources(frame_);
   return true;
 }
Index: chromium-browser-65.0.3325.181/cc/resources/display_resource_provider.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/display_resource_provider.cc
+++ chromium-browser-65.0.3325.181/cc/resources/display_resource_provider.cc
@@ -8,6 +8,7 @@
 #include "components/viz/common/gpu/context_provider.h"
 #include "components/viz/common/resources/resource_format_utils.h"
 #include "components/viz/common/resources/shared_bitmap_manager.h"
+#include "components/viz/common/resources/shared_image_x11.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
 #include "third_party/skia/include/gpu/GrBackendSurface.h"
 
@@ -368,6 +369,9 @@ void DisplayResourceProvider::ReceiveFro
                                   it->color_space));
       resource->has_shared_bitmap_id = true;
       resource->shared_bitmap_id = it->mailbox_holder.mailbox;
+      // (Pi) Set overlay candidate on shared memory resources if the source
+      // thought it was a good idea
+      resource->is_overlay_candidate = it->is_overlay_candidate;
     } else {
       resource = InsertResource(
           local_id,
@@ -389,6 +393,7 @@ void DisplayResourceProvider::ReceiveFro
       resource->wants_promotion_hint = it->wants_promotion_hint;
 #endif
     }
+    resource->stride = it->stride;
     resource->child_id = child;
     // Don't allocate a texture for a child.
     resource->allocated = true;
@@ -652,6 +657,35 @@ DisplayResourceProvider::ScopedReadLockS
   resource_provider_->UnlockForRead(resource_id_);
 }
 
+DisplayResourceProvider::ScopedReadLockSharedImageX11::ScopedReadLockSharedImageX11(
+    DisplayResourceProvider* resource_provider,
+    viz::ResourceId resource_id)
+    : xshm_(nullptr),
+      resource_provider_(resource_provider),
+      resource_id_(resource_id)
+{
+  const viz::internal::Resource* resource = resource_provider->LockForRead(resource_id);
+//***********************************************************************
+//#error Check what exactly PopulateSkBitmapWithResource does
+  if (resource->has_shared_bitmap_id) {
+    xshm_ = resource_provider_->shared_bitmap_manager_->GetSharedImageX11ForBitmap(resource->shared_bitmap_id);
+  }
+  if (xshm_) {
+    xshm_->set_size(resource->size, resource->stride);
+  }
+  else {
+    // No point in holding a lock if we don't have any memory
+    resource_provider_->UnlockForRead(resource_id);
+  }
+}
+
+DisplayResourceProvider::ScopedReadLockSharedImageX11::~ScopedReadLockSharedImageX11() {
+  if (xshm_) {
+    resource_provider_->UnlockForRead(resource_id_);
+  }
+}
+
+
 DisplayResourceProvider::SynchronousFence::SynchronousFence(
     gpu::gles2::GLES2Interface* gl)
     : gl_(gl), has_synchronized_(true) {}
Index: chromium-browser-65.0.3325.181/cc/resources/display_resource_provider.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/display_resource_provider.h
+++ chromium-browser-65.0.3325.181/cc/resources/display_resource_provider.h
@@ -155,6 +155,27 @@ class CC_EXPORT DisplayResourceProvider
     DISALLOW_COPY_AND_ASSIGN(ScopedReadLockSoftware);
   };
 
+  class CC_EXPORT ScopedReadLockSharedImageX11 {
+  public:
+    ScopedReadLockSharedImageX11(DisplayResourceProvider* resource_provider,
+                           viz::ResourceId resource_id);
+    ~ScopedReadLockSharedImageX11();
+
+    viz::SharedImageX11 * shared_image_x11() const {
+      DCHECK(valid());
+      return xshm_;
+    }
+
+    bool valid() const { return xshm_ != nullptr; }
+
+   private:
+    viz::SharedImageX11 * xshm_;
+    DisplayResourceProvider* resource_provider_;
+    viz::ResourceId resource_id_;
+
+    DISALLOW_COPY_AND_ASSIGN(ScopedReadLockSharedImageX11);
+  };
+
   // All resources that are returned to children while an instance of this
   // class exists will be stored and returned when the instance is destroyed.
   class CC_EXPORT ScopedBatchReturnResources {
Index: chromium-browser-65.0.3325.181/cc/resources/layer_tree_resource_provider.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/layer_tree_resource_provider.cc
+++ chromium-browser-65.0.3325.181/cc/resources/layer_tree_resource_provider.cc
@@ -12,6 +12,7 @@
 #include "components/viz/common/resources/platform_color.h"
 #include "components/viz/common/resources/resource_format_utils.h"
 #include "components/viz/common/resources/shared_bitmap_manager.h"
+#include "components/viz/common/resources/shared_image_x11.h"
 #include "gpu/GLES2/gl2extchromium.h"
 #include "gpu/command_buffer/client/context_support.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
@@ -19,6 +20,7 @@
 #include "gpu/command_buffer/client/raster_interface.h"
 #include "gpu/command_buffer/common/capabilities.h"
 #include "gpu/command_buffer/common/gpu_memory_buffer_support.h"
+#include "media/base/video_frame.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 
 using gpu::gles2::GLES2Interface;
@@ -463,6 +465,33 @@ viz::ResourceId LayerTreeResourceProvide
   return id;
 }
 
+viz::ResourceId LayerTreeResourceProvider::CreateFrameRef(const scoped_refptr<media::VideoFrame>& video_frame)
+{
+  std::unique_ptr<viz::SharedBitmap> bitmap(shared_bitmap_manager_->AllocateSharedFrame(video_frame));
+
+  if (bitmap == nullptr) {
+    return 0;
+  }
+
+  const gfx::Size size(video_frame->coded_size());
+
+  const viz::ResourceId id = next_id_++;
+  viz::internal::Resource* resource = InsertResource(
+      id,
+      viz::internal::Resource(
+          size,
+          viz::internal::Resource::INTERNAL,
+          viz::ResourceTextureHint::kDefault,
+          viz::ResourceType::kBitmap, viz::RGBA_8888,
+          video_frame->ColorSpace()));
+
+  resource->SetSharedBitmap(bitmap.get());
+  resource->owned_shared_bitmap = std::move(bitmap);
+  resource->is_overlay_candidate = true;
+  resource->stride = video_frame->stride(0);
+  return id;
+}
+
 void LayerTreeResourceProvider::DeleteResource(viz::ResourceId id) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   ResourceMap::iterator it = resources_.find(id);
@@ -504,6 +533,16 @@ void LayerTreeResourceProvider::RemoveIm
   }
 }
 
+viz::SharedImageX11 *
+LayerTreeResourceProvider::GetSharedImageX11(const viz::ResourceId id)
+{
+  viz::internal::Resource * const resource = GetResource(id);
+  if (!resource->has_shared_bitmap_id) {
+    return nullptr;
+  }
+  return shared_bitmap_manager_->GetSharedImageX11ForBitmap(resource->shared_bitmap_id);
+}
+
 void LayerTreeResourceProvider::CopyToResource(viz::ResourceId id,
                                                const uint8_t* image,
                                                const gfx::Size& image_size) {
@@ -659,10 +698,12 @@ void LayerTreeResourceProvider::Transfer
     viz::TransferableResource* resource) {
   DCHECK(!source->locked_for_write);
   DCHECK(source->allocated);
+  CHECK(source->stride < 0x10000);
   resource->id = id;
   resource->format = source->format;
   resource->buffer_format = source->buffer_format;
   resource->filter = source->filter;
+  resource->stride = source->stride;
   resource->size = source->size;
   resource->read_lock_fences_enabled = source->read_lock_fences_enabled;
   resource->is_overlay_candidate = source->is_overlay_candidate;
Index: chromium-browser-65.0.3325.181/cc/resources/layer_tree_resource_provider.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/layer_tree_resource_provider.h
+++ chromium-browser-65.0.3325.181/cc/resources/layer_tree_resource_provider.h
@@ -74,6 +74,9 @@ class CC_EXPORT LayerTreeResourceProvide
   viz::ResourceId CreateBitmapResource(const gfx::Size& size,
                                        const gfx::ColorSpace& color_space);
 
+  // (Pi) Wrap a frame into a resource
+  viz::ResourceId CreateFrameRef(const scoped_refptr<media::VideoFrame>& video_frame);
+
   void DeleteResource(viz::ResourceId id);
 
   // Receives a resource from an external client that can be used in compositor
@@ -83,6 +86,9 @@ class CC_EXPORT LayerTreeResourceProvide
   // Removes an imported resource, which will call the ReleaseCallback given
   // originally, once the resource is no longer in use by any compositor frame.
   void RemoveImportedResource(viz::ResourceId);
+
+  viz::SharedImageX11 * GetSharedImageX11(const viz::ResourceId id);
+
   // Update pixels from image, copying source_rect (in image) to dest_offset (in
   // the resource).
   void CopyToResource(viz::ResourceId id,
Index: chromium-browser-65.0.3325.181/cc/resources/resource_provider.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/resource_provider.cc
+++ chromium-browser-65.0.3325.181/cc/resources/resource_provider.cc
@@ -186,7 +186,8 @@ void ResourceProvider::PopulateSkBitmapW
   DCHECK_EQ(viz::RGBA_8888, resource->format);
   SkImageInfo info = SkImageInfo::MakeN32Premul(resource->size.width(),
                                                 resource->size.height());
-  sk_bitmap->installPixels(info, resource->pixels, info.minRowBytes());
+  const size_t row_bytes = (resource->stride != 0) ? resource->stride : info.minRowBytes();
+  sk_bitmap->installPixels(info, resource->pixels, row_bytes);
 }
 
 void ResourceProvider::WaitSyncTokenInternal(
Index: chromium-browser-65.0.3325.181/cc/resources/resource_provider.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/resource_provider.h
+++ chromium-browser-65.0.3325.181/cc/resources/resource_provider.h
@@ -42,8 +42,19 @@ class GLES2Interface;
 }
 }
 
+namespace gfx {
+class Rect;
+class Vector2d;
+}
+
+namespace media {
+class VideoFrame;
+}
+
 namespace viz {
 class ContextProvider;
+class SharedBitmapManager;
+class SharedImageX11;
 }  // namespace viz
 
 namespace cc {
Index: chromium-browser-65.0.3325.181/cc/resources/video_resource_updater.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/video_resource_updater.cc
+++ chromium-browser-65.0.3325.181/cc/resources/video_resource_updater.cc
@@ -97,6 +97,7 @@ VideoFrameExternalResources::ResourceTyp
     case media::PIXEL_FORMAT_YUV422P12:
     case media::PIXEL_FORMAT_YUV444P12:
     case media::PIXEL_FORMAT_Y16:
+    case media::PIXEL_FORMAT_MMAL_BUFFER:
     case media::PIXEL_FORMAT_UNKNOWN:
       break;
   }
@@ -315,6 +316,7 @@ VideoFrameExternalResources VideoResourc
 
   // Only YUV and Y16 software video frames are supported.
   DCHECK(media::IsYuvPlanar(input_frame_format) ||
+         input_frame_format == media::PIXEL_FORMAT_MMAL_BUFFER ||
          input_frame_format == media::PIXEL_FORMAT_Y16);
 
   const bool software_compositor = context_provider_ == nullptr;
@@ -359,6 +361,37 @@ VideoFrameExternalResources VideoResourc
       ++it;
   }
 
+  // If we have an mmal buffer then try to extract its shared memory and
+  // pass that on without copying
+  if (input_frame_format == media::PIXEL_FORMAT_MMAL_BUFFER)
+  {
+    viz::ResourceId resource_id = resource_provider_->CreateFrameRef(video_frame);
+    if (resource_id != 0) {
+      const gfx::Size size(video_frame->stride(0) / 4, video_frame->rows(0));
+
+      all_resources_.push_front(
+          PlaneResource(resource_id, size, output_resource_format, gpu::Mailbox()));
+
+      // ??? Do I really need / want plane resource ???
+
+      PlaneResource& plane_resource = all_resources_.front();
+
+      plane_resource.SetUniqueId(video_frame->unique_id(), 0);
+
+      VideoFrameExternalResources external_resources;
+
+      // * software_resources are plane_resource.resource_id()
+
+//      LOG(ERROR) << "FrameRef, id:" << resource_id << ", plane id: " << plane_resource.resource_id() << ", size=" << size.ToString();
+
+      external_resources.software_resource = plane_resource.resource_id();
+      external_resources.software_release_callback = base::Bind(
+          &RemoveFrameResource, weak_ptr_factory_.GetWeakPtr(), resource_id);
+      external_resources.type = VideoFrameExternalResources::SOFTWARE_RESOURCE;
+      return external_resources;
+    }
+  }
+
   const int max_resource_size = resource_provider_->max_texture_size();
   std::vector<ResourceList::iterator> plane_resources;
   for (size_t i = 0; i < output_plane_count; ++i) {
@@ -914,6 +947,42 @@ VideoFrameExternalResources VideoResourc
   return external_resources;
 }
 
+void VideoResourceUpdater::RemoveFrameResource(
+  base::WeakPtr<VideoResourceUpdater> updater,
+  viz::ResourceId resource_id,
+  const gpu::SyncToken& sync_token,
+  bool lost_resource)
+{
+  if (!updater.get()) {
+    // Resource was already deleted.
+    return;
+  }
+
+  const ResourceList::iterator resource_it = std::find_if(
+      updater->all_resources_.begin(), updater->all_resources_.end(),
+      [resource_id](const PlaneResource& plane_resource) {
+        return plane_resource.resource_id() == resource_id;
+      });
+  if (resource_it == updater->all_resources_.end())
+  {
+    LOG(ERROR) << __func__ << " id:" << resource_id << " not found";
+    return;
+  }
+
+//  LOG(ERROR) << __func__ << " id:" << resource_id << " found, lost=" << lost_resource;
+
+  viz::ContextProvider* context_provider = updater->context_provider_;
+  if (context_provider && sync_token.HasData()) {
+    context_provider->ContextGL()->WaitSyncTokenCHROMIUM(
+        sync_token.GetConstData());
+  }
+
+  // We always delete this once we are done with it
+  // The buffer itself is managed by the decoder
+  resource_it->clear_refs();
+  updater->DeleteResource(resource_it);
+}
+
 // static
 void VideoResourceUpdater::RecycleResource(
     base::WeakPtr<VideoResourceUpdater> updater,
Index: chromium-browser-65.0.3325.181/cc/resources/video_resource_updater.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/cc/resources/video_resource_updater.h
+++ chromium-browser-65.0.3325.181/cc/resources/video_resource_updater.h
@@ -187,6 +187,10 @@ class CC_EXPORT VideoResourceUpdater {
   VideoFrameExternalResources CreateForSoftwarePlanes(
       scoped_refptr<media::VideoFrame> video_frame);
 
+  static void RemoveFrameResource(base::WeakPtr<VideoResourceUpdater> updater,
+                              unsigned resource_id,
+                              const gpu::SyncToken& sync_token,
+                              bool lost_resource);
   static void RecycleResource(base::WeakPtr<VideoResourceUpdater> updater,
                               unsigned resource_id,
                               const gpu::SyncToken& sync_token,
Index: chromium-browser-65.0.3325.181/chrome/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/chrome/BUILD.gn
+++ chromium-browser-65.0.3325.181/chrome/BUILD.gn
@@ -24,6 +24,7 @@ import("//third_party/WebKit/public/publ
 import("//third_party/widevine/cdm/widevine.gni")
 import("//tools/resources/generate_resource_whitelist.gni")
 import("//v8/gni/v8.gni")
+import("//build/config/sysroot.gni")
 
 if (is_android) {
   import("//build/config/android/rules.gni")
@@ -292,6 +293,18 @@ if (!is_android && !is_mac) {
         if (enable_mus) {
           deps += [ "//mash/common" ]
         }
+
+        # Add pi link stuff
+        # * is there a better place?
+        ldflags += [
+         "-L$sysroot/opt/vc/lib",
+         "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+         "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+        ]
+        if (symbol_level >= 2) {
+          # For debug symbols!
+          ldflags += [ "-Wl,--long-plt" ]
+        }
       }
 
       # These files are used by the installer so we need a public dep.
Index: chromium-browser-65.0.3325.181/chrome/app/chrome_main_delegate.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/chrome/app/chrome_main_delegate.cc
+++ chromium-browser-65.0.3325.181/chrome/app/chrome_main_delegate.cc
@@ -51,6 +51,7 @@
 #include "components/crash/core/common/crash_key.h"
 #include "components/crash/core/common/crash_keys.h"
 #include "components/nacl/common/features.h"
+#include "components/version_info/pi_patch_version_info.h"
 #include "components/version_info/version_info.h"
 #include "content/public/common/content_client.h"
 #include "content/public/common/content_paths.h"
@@ -332,6 +333,15 @@ bool HandleVersionSwitches(const base::C
   }
 #endif
 
+  if (command_line.HasSwitch(switches::kPiPatchVersion)) {
+    printf("%s %s %s\nPi patch: %s\n",
+           version_info::GetProductName().c_str(),
+           version_info::GetVersionNumber().c_str(),
+           chrome::GetChannelString().c_str(),
+           version_info::GetPiPatchVersionString().c_str());
+    return true;
+  }
+
   if (command_line.HasSwitch(switches::kVersion)) {
     printf("%s %s %s\n",
            version_info::GetProductName().c_str(),
Index: chromium-browser-65.0.3325.181/chrome/common/chrome_switches.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/chrome/common/chrome_switches.cc
+++ chromium-browser-65.0.3325.181/chrome/common/chrome_switches.cc
@@ -997,6 +997,9 @@ const char kEnableNewAppMenuIcon[] = "en
 const char kUseSystemDefaultPrinter[] = "use-system-default-printer";
 #endif
 
+// Print the patch version and return
+const char kPiPatchVersion[] = "pi-patch-version";
+
 bool ExtensionsDisabled(const base::CommandLine& command_line) {
   return command_line.HasSwitch(switches::kDisableExtensions) ||
          command_line.HasSwitch(switches::kDisableExtensionsExcept);
Index: chromium-browser-65.0.3325.181/chrome/common/chrome_switches.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/chrome/common/chrome_switches.h
+++ chromium-browser-65.0.3325.181/chrome/common/chrome_switches.h
@@ -326,6 +326,8 @@ extern const char kEnableNewAppMenuIcon[
 extern const char kUseSystemDefaultPrinter[];
 #endif
 
+extern const char kPiPatchVersion[];
+
 bool ExtensionsDisabled(const base::CommandLine& command_line);
 bool ExtensionsDisabled();
 
Index: chromium-browser-65.0.3325.181/components/nacl/loader/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/nacl/loader/BUILD.gn
+++ chromium-browser-65.0.3325.181/components/nacl/loader/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/nacl/config.gni")
 import("//components/nacl/features.gni")
 import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
+import("//build/config/sysroot.gni")
 
 assert(enable_nacl)
 
@@ -144,6 +145,16 @@ if (is_linux) {
     data_deps = [
       "//native_client/src/trusted/service_runtime/linux:bootstrap",
     ]
+
+    if (current_cpu == "arm" && !is_component_build) {
+      # Add pi link stuff
+      # * is there a better place?
+      ldflags += [
+       "-L$sysroot/opt/vc/lib",
+       "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+       "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+      ]
+    }
   }
 
   # For setting up nacl_helper.
Index: chromium-browser-65.0.3325.181/components/version_info/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/version_info/BUILD.gn
+++ chromium-browser-65.0.3325.181/components/version_info/BUILD.gn
@@ -14,6 +14,9 @@ static_library("version_info") {
   sources = [
     "version_info.cc",
     "version_info.h",
+    "pi_patch_version_info.cc",
+    "pi_patch_version_info.h",
+    "pi_patch_version_values.h",
   ]
 
   deps = [
Index: chromium-browser-65.0.3325.181/components/version_info/pi_patch_version_info.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/version_info/pi_patch_version_info.cc
@@ -0,0 +1,13 @@
+#include "components/version_info/pi_patch_version_info.h"
+#include "components/version_info/pi_patch_version_values.h"
+
+namespace version_info {
+
+std::string GetPiPatchVersionString() {
+  return PI_PATCH_VERSION_STRING;
+}
+
+}  // namespace version_info
+
+
+
Index: chromium-browser-65.0.3325.181/components/version_info/pi_patch_version_info.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/version_info/pi_patch_version_info.h
@@ -0,0 +1,14 @@
+#ifndef COMPONENTS_PI_PATCH_VERSION_INFO_VERSION_INFO_H_
+#define COMPONENTS_PI_PATCH_VERSION_INFO_VERSION_INFO_H_
+
+#include <string>
+
+namespace version_info {
+
+// Returns a string with the patch tag for our patches
+std::string GetPiPatchVersionString();
+
+}  // namespace version_info
+#endif  // COMPONENTS_VERSION_INFO_VERSION_INFO_H_
+
+
Index: chromium-browser-65.0.3325.181/components/version_info/pi_patch_version_values.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/version_info/pi_patch_version_values.h
@@ -0,0 +1,2 @@
+// Pi patch version - generated by pi-util/settag.py
+#define PI_PATCH_VERSION_STRING "mmal_2.15"
Index: chromium-browser-65.0.3325.181/components/viz/client/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/client/BUILD.gn
+++ chromium-browser-65.0.3325.181/components/viz/client/BUILD.gn
@@ -21,6 +21,8 @@ viz_component("client") {
 
   defines = [ "VIZ_CLIENT_IMPLEMENTATION" ]
 
+#  deps = [ "//media" ]
+
   public_deps = [
     "//base",
     "//cc",
Index: chromium-browser-65.0.3325.181/components/viz/client/client_shared_bitmap_manager.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/client/client_shared_bitmap_manager.cc
+++ chromium-browser-65.0.3325.181/components/viz/client/client_shared_bitmap_manager.cc
@@ -13,6 +13,8 @@
 #include "base/process/process_metrics.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "media/base/video_frame.h"
+#include "media/filters/mmal_video_decoder.h"
 #include "mojo/public/cpp/system/platform_handle.h"
 #include "ui/gfx/geometry/size.h"
 
@@ -64,6 +66,28 @@ class ClientSharedBitmap : public Shared
   std::unique_ptr<base::SharedMemory> shared_memory_holder_;
 };
 
+// Keeps a ref on a frame so we don't reuse it before the host has
+// finished with it
+class FrameSharedBitmap : public SharedBitmap {
+  scoped_refptr<media::VideoFrame> frame_;
+
+ public:
+  FrameSharedBitmap(scoped_refptr<media::VideoFrame> frame,
+                    const SharedBitmapId& id)
+      : SharedBitmap(frame->data(0), id, 0),
+        frame_(frame)
+  {
+  }
+
+  ~FrameSharedBitmap() override {
+  }
+
+  base::SharedMemoryHandle GetSharedMemoryHandle() const override
+  {
+    return frame_->shared_memory_handle();
+  }
+};
+
 // Collect extra information for debugging bitmap creation failures.
 void CollectMemoryUsageAndDie(const gfx::Size& size, size_t alloc_size) {
 #if defined(OS_WIN)
@@ -142,6 +166,55 @@ std::unique_ptr<SharedBitmap> ClientShar
       sequence_number);
 }
 
+static void kill_shared_id(
+  scoped_refptr<mojom::ThreadSafeSharedBitmapAllocationNotifierPtr> message_filter,
+  const SharedBitmapId id)
+{
+  (*message_filter)->DidDeleteSharedBitmap(id);
+}
+
+std::unique_ptr<SharedBitmap> ClientSharedBitmapManager::AllocateSharedFrame(
+    const scoped_refptr<media::VideoFrame>& video_frame) {
+
+  const scoped_refptr<media::MmalVideoFrame> mmal_frame = media::MmalVideoFrame::Coerce(video_frame);
+
+  // Give up if this doesn't look like a shared frame
+  if (mmal_frame == nullptr || !mmal_frame->shared_memory_handle().IsValid())
+  {
+//    LOG(ERROR) << "Not shared: frame=" << mmal_frame;
+    return std::unique_ptr<SharedBitmap>();
+  }
+
+//  const SharedBitmapId& existing_id = mmal_frame->get_id();
+  const SharedBitmapId& existing_id(mmal_frame->get_id());
+  if (!existing_id.IsZero()) {
+      return base::MakeUnique<FrameSharedBitmap>(mmal_frame, existing_id);
+  }
+  else
+  {
+      const size_t memory_size = video_frame->stride(0) * video_frame->rows(0);
+      const SharedBitmapId id = SharedBitmap::GenerateId();
+
+      base::SharedMemoryHandle handle_to_send =
+          base::SharedMemory::DuplicateHandle(mmal_frame->shared_memory_handle());
+      if (!base::SharedMemory::IsHandleValid(handle_to_send)) {
+        LOG(ERROR) << "Failed to duplicate shared memory handle for bitmap.";
+        return nullptr;
+      }
+
+      {
+        base::AutoLock lock(lock_);
+        (*shared_bitmap_allocation_notifier_)->DidAllocateSharedBitmap(
+          mojo::WrapSharedMemoryHandle(handle_to_send, memory_size,
+            mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly),
+          id, true /* is_image */);
+      }
+
+      mmal_frame->set_id_and_kill(id, base::Bind(kill_shared_id, shared_bitmap_allocation_notifier_, id));
+      return base::MakeUnique<FrameSharedBitmap>(mmal_frame, id);
+  }
+}
+
 std::unique_ptr<SharedBitmap> ClientSharedBitmapManager::GetSharedBitmapFromId(
     const gfx::Size&,
     const SharedBitmapId&) {
@@ -176,9 +249,14 @@ uint32_t ClientSharedBitmapManager::Noti
   {
     base::AutoLock lock(lock_);
     (*shared_bitmap_allocation_notifier_)
-        ->DidAllocateSharedBitmap(std::move(buffer_handle), id);
+        ->DidAllocateSharedBitmap(std::move(buffer_handle), id, false);
     return ++last_sequence_number_;
   }
 }
 
+SharedImageX11 * ClientSharedBitmapManager::GetSharedImageX11ForBitmap(const SharedBitmapId& id)
+{
+    return nullptr;
+}
+
 }  // namespace viz
Index: chromium-browser-65.0.3325.181/components/viz/client/client_shared_bitmap_manager.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/client/client_shared_bitmap_manager.h
+++ chromium-browser-65.0.3325.181/components/viz/client/client_shared_bitmap_manager.h
@@ -33,6 +33,8 @@ class VIZ_CLIENT_EXPORT ClientSharedBitm
   // SharedBitmapManager implementation.
   std::unique_ptr<SharedBitmap> AllocateSharedBitmap(
       const gfx::Size& size) override;
+  std::unique_ptr<SharedBitmap> AllocateSharedFrame(
+      const scoped_refptr<media::VideoFrame>& video_frame) override;
   std::unique_ptr<SharedBitmap> GetSharedBitmapFromId(
       const gfx::Size&,
       const SharedBitmapId&) override;
@@ -40,6 +42,8 @@ class VIZ_CLIENT_EXPORT ClientSharedBitm
   std::unique_ptr<SharedBitmap> GetBitmapForSharedMemory(
       base::SharedMemory* mem);
 
+  SharedImageX11 * GetSharedImageX11ForBitmap(const SharedBitmapId& id) override;
+
  private:
   uint32_t NotifyAllocatedSharedBitmap(base::SharedMemory* memory,
                                        const SharedBitmapId& id);
Index: chromium-browser-65.0.3325.181/components/viz/common/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/common/BUILD.gn
+++ chromium-browser-65.0.3325.181/components/viz/common/BUILD.gn
@@ -114,9 +114,12 @@ viz_component("common") {
     "resources/resource_texture_hint.h",
     "resources/resource_type.h",
     "resources/returned_resource.h",
+    "resources/shared_bitmap_manager.cc",
     "resources/shared_bitmap_manager.h",
     "resources/single_release_callback.cc",
     "resources/single_release_callback.h",
+    "resources/shared_image_x11.cc",
+    "resources/shared_image_x11.h",
     "resources/transferable_resource.cc",
     "resources/transferable_resource.h",
     "surfaces/frame_sink_id.cc",
@@ -170,8 +173,14 @@ viz_component("common") {
     "//ui/latency",
   ]
 
+  configs = []
+
+  # For shared X suff - maybe should be elsewhere now?
+  configs += [ "//build/config/linux:x11" ]
+
+
   if (enable_vulkan) {
-    configs = [ "//third_party/vulkan:vulkan_config" ]
+    configs += [ "//third_party/vulkan:vulkan_config" ]
     deps += [ "//gpu/vulkan" ]
   }
 
Index: chromium-browser-65.0.3325.181/components/viz/common/resources/resource.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/common/resources/resource.h
+++ chromium-browser-65.0.3325.181/components/viz/common/resources/resource.h
@@ -164,6 +164,8 @@ struct VIZ_COMMON_EXPORT Resource {
   // ownership of the resource from the client to the service, and in the GL
   // drawing code before reading from the texture.
   scoped_refptr<ResourceFence> read_lock_fence;
+  // Stride for frames
+  size_t stride = 0;
   // Size of the resource in pixels.
   gfx::Size size;
   // Where the resource was originally allocated. Either internally by the
Index: chromium-browser-65.0.3325.181/components/viz/common/resources/shared_bitmap_manager.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/common/resources/shared_bitmap_manager.cc
@@ -0,0 +1,21 @@
+#include "components/viz/common/resources/shared_bitmap_manager.h"
+
+namespace viz {
+
+std::unique_ptr<SharedBitmap>
+SharedBitmapManager::AllocateSharedFrame(
+      const scoped_refptr<media::VideoFrame>& video_frame)
+{
+    NOTREACHED();
+    return std::unique_ptr<SharedBitmap>();
+}
+
+
+SharedImageX11 * SharedBitmapManager::GetSharedImageX11ForBitmap(const SharedBitmapId& id)
+{
+    return nullptr;
+}
+
+} // namespace cc
+
+
Index: chromium-browser-65.0.3325.181/components/viz/common/resources/shared_bitmap_manager.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/common/resources/shared_bitmap_manager.h
+++ chromium-browser-65.0.3325.181/components/viz/common/resources/shared_bitmap_manager.h
@@ -8,12 +8,20 @@
 #include <memory>
 
 #include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "components/viz/common/viz_common_export.h"
 #include "components/viz/common/quads/shared_bitmap.h"
 #include "ui/gfx/geometry/size.h"
 
+namespace media {
+class VideoFrame;
+}
+
 namespace viz {
 
-class SharedBitmapManager {
+class SharedImageX11;
+
+class VIZ_COMMON_EXPORT SharedBitmapManager {
  public:
   SharedBitmapManager() {}
   virtual ~SharedBitmapManager() {}
@@ -24,7 +32,12 @@ class SharedBitmapManager {
       const gfx::Size&,
       const SharedBitmapId&) = 0;
 
- private:
+  virtual std::unique_ptr<SharedBitmap> AllocateSharedFrame(
+      const scoped_refptr<media::VideoFrame>& video_frame);
+  virtual SharedImageX11 * GetSharedImageX11ForBitmap(
+      const SharedBitmapId& id);
+
+private:
   DISALLOW_COPY_AND_ASSIGN(SharedBitmapManager);
 };
 
Index: chromium-browser-65.0.3325.181/components/viz/common/resources/shared_image_x11.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/common/resources/shared_image_x11.cc
@@ -0,0 +1,438 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "base/memory/ptr_util.h"
+#include "components/viz/common/resources/shared_image_x11.h"
+#include "ui/gfx/x/x11_types.h"
+
+#ifdef __ARMEL__
+#define XCB_IMAGE_SUPPORT 1
+#else
+#define XCB_IMAGE_SUPPORT 0
+#endif
+
+#include <X11/Xlib-xcb.h>
+#include <xcb/shm.h>
+#if XCB_IMAGE_SUPPORT
+#include <xcb/xcb_image.h>
+
+namespace viz
+{
+
+class XcbCookieTrue : public XcbCookie
+{
+public:
+  bool sync() override {return true;}
+};
+
+
+class XcbCookieVoid : public XcbCookie
+{
+  xcb_connection_t * const xcbc_;
+  const xcb_void_cookie_t cookie_;
+  xcb_generic_error_t * err_;
+  bool sync_done_;
+
+public:
+  XcbCookieVoid(xcb_connection_t * const xcbc, const xcb_void_cookie_t& cookie) :
+    xcbc_(xcbc),
+    cookie_(cookie),
+    sync_done_(false)
+  {
+  }
+
+  bool sync() override
+  {
+    if (!sync_done_)
+    {
+      err_ = xcb_request_check(xcbc_, cookie_);
+      sync_done_ = true;
+    }
+    return err_ == nullptr;
+  }
+
+  ~XcbCookieVoid() override
+  {
+    sync();
+    if (err_ != nullptr)
+      free(err_);
+  }
+};
+
+
+
+
+class SharedImageX11::X
+{
+  // ?? There must be a STL template that does this wrapping for me...
+  struct XcbImageDeleter
+  {
+    void operator ()(xcb_image_t * const img) {
+      xcb_image_destroy(img);
+    }
+  };
+
+  xcb_connection_t * xcbc_;
+  xcb_shm_seg_t shm_seg_;
+
+  // Use an image structure to store image info
+  // Will calculate expected strides for us
+  std::unique_ptr<xcb_image_t, XcbImageDeleter> img_;
+  bool attached_;
+
+public:
+  X(xcb_connection_t * const xcbc, unsigned int depth, const gfx::Size& size) :
+    xcbc_(xcbc),
+    shm_seg_(~0U),
+    img_(xcb_image_create_native(xcbc_, size.width(), size.height(), XCB_IMAGE_FORMAT_Z_PIXMAP, depth, nullptr, ~0U, nullptr)),
+    attached_(false)
+  {
+  }
+
+  ~X()
+  {
+//    LOG(ERROR) << __func__ << ": shmid=" << std::hex << shminfo_.shmid;
+    if (attached_)
+      xcb_shm_detach(xcbc_, shm_seg_);
+  }
+
+  bool check() const
+  {
+    return img_ != nullptr;
+  }
+
+  size_t stride() const
+  {
+    return img_ == nullptr ? 0 : img_->stride;
+  }
+
+  size_t image_size() const
+  {
+    if (img_ == nullptr)
+      return 0;
+
+    return img_->size;
+  }
+
+  bool attach_smh(const base::SharedMemoryHandle& shmfd)
+  {
+    if (attached_)
+    {
+      LOG(ERROR) << "Already attached";
+      return false;
+    }
+    if (img_ == nullptr)
+    {
+      LOG(ERROR) << "No image";
+      return false;
+    }
+
+    shm_seg_ = xcb_generate_id(xcbc_); // Error value is ~0U
+
+    // This closes the fd once sent so must dup to avoid local confusion
+    XcbCookieVoid err(xcbc_,
+      xcb_shm_attach_fd_checked(xcbc_, shm_seg_, dup(shmfd.GetHandle()), 1));
+    if (!err.sync())
+    {
+      LOG(ERROR) << "SHM attach failed";
+      return false;
+    }
+
+    attached_ = true;
+    return true;
+  }
+
+  // Messy declaration
+  std::unique_ptr<XcbCookie> put_image(const Drawable drawable, const xcb_gcontext_t cid, const gfx::Rect& rect, const gfx::Rect& src_rect)
+  {
+    if (!attached_)
+    {
+      LOG(ERROR) << "Not attached";
+      return nullptr;
+    }
+    if (img_ == nullptr)
+    {
+      LOG(ERROR) << "No image";
+      return nullptr;
+    }
+
+    // Xlib XID types should be compatible with xcb
+    // This includes Drawable, gcontext_t is extractable from GC
+
+    return base::MakeUnique<XcbCookieVoid>(xcbc_,
+      xcb_shm_put_image_checked(xcbc_, drawable, cid,
+        img_->width, img_->height, /* total width/height */
+        src_rect.x(), src_rect.y(),
+        rect.width(), rect.height(),  /* ?? should be src_width, src_height ?? */
+        rect.x(), rect.y(),
+        img_->depth,  // bits per pixel (probably)
+        img_->format,
+        0, /* send event */
+        shm_seg_,
+        0  /* offset */));
+  }
+
+  std::string ToString() const
+  {
+    if (img_ == nullptr)
+    {
+      return "<null>";
+    }
+
+    std::ostringstream s;
+    s << "imgsize=" << img_->width << "x" << img_->height;
+    return s.str();
+  }
+};
+
+
+
+
+SharedImageX11::SharedImageX11(std::unique_ptr<base::SharedMemory>&& shm) :
+  shm_(std::move(shm)),
+  stride_(0),
+  buffer_size_(0)
+{
+}
+
+SharedImageX11::SharedImageX11(const base::SharedMemoryHandle& shmh, const bool ro) :
+  shm_(base::MakeUnique<base::SharedMemory>(shmh, ro)),
+  stride_(0),
+  buffer_size_(0)
+{
+}
+
+SharedImageX11::SharedImageX11() :
+  shm_(base::MakeUnique<base::SharedMemory>()),
+  stride_(0),
+  buffer_size_(0)
+{
+}
+
+SharedImageX11::~SharedImageX11()
+{
+}
+
+
+// Check if the X Shared Memory extension is available.
+bool
+SharedImageX11::check_support(Display *const display)
+{
+#if !XCB_IMAGE_SUPPORT
+  return false;
+#else
+  xcb_connection_t * const xcbc = XGetXCBConnection(display);
+  bool rv = false;
+
+  if (xcbc == nullptr)
+  {
+    LOG(ERROR) << "Unable to get xcb connection";
+    return false;
+  }
+
+  // Do not free this result
+  const xcb_query_extension_reply_t * xd;
+  if ((xd = xcb_get_extension_data(xcbc, &xcb_shm_id)) == nullptr ||
+      xd->response_type != 1 ||  // X_Reply - doesn't seem to be defined in xcb
+      !xd->present)
+  {
+    LOG(WARNING) << "SHM extension not supported";
+    return false;
+  }
+
+  xcb_generic_error_t * err = nullptr;
+  xcb_shm_query_version_reply_t * const qvr =
+    xcb_shm_query_version_reply(xcbc, xcb_shm_query_version(xcbc), &err);
+
+  if (err != nullptr)
+    LOG(ERROR) << __func__ << ": Error reply: code=" << err->error_code;
+  else if (qvr == nullptr || qvr->response_type != 1)
+    LOG(ERROR) << "SHM query version reply bad";
+  else if (qvr->major_version < 1 || (qvr->major_version == 1 && qvr->minor_version < 2))
+    LOG(WARNING) << "SHM version " << qvr->major_version << "." << qvr->minor_version <<" is too low; need 1.2";
+  else
+  {
+      LOG(INFO) << "SHM version " << qvr->major_version << "." << qvr->minor_version << ": OK";
+      rv = true;
+  }
+
+  if (err != nullptr)
+    free(err);
+  if (qvr != nullptr)
+    free(qvr);
+
+  return rv;
+#endif
+}
+
+
+
+bool
+SharedImageX11::create_image(XDisplay * const display, const XWindowAttributes& attributes)
+{
+  if (x_ != nullptr)
+  {
+    // Assume everything matches
+    return true;
+  }
+
+  xcb_connection_t * const xcbc = XGetXCBConnection(display);
+  if (stride_ == 0)
+  {
+    // Let X pick our stride (probably creating a new image)
+    std::unique_ptr<X> x(base::MakeUnique<X>(xcbc, attributes.depth, size_));
+    if (!x->check())
+      return false;
+    x_ = std::move(x);
+  }
+  else
+  {
+    std::unique_ptr<X> x(base::MakeUnique<X>(xcbc, attributes.depth,
+      gfx::Size(stride_ / 4, size_.height())));
+    if (x->stride() != stride_)
+    {
+      LOG(ERROR) << "Generated mismatched strides: " << x->stride() << "/" << stride_;
+      return false;
+    }
+    x_ = std::move(x);
+  }
+
+  if (buffer_size_ == 0)
+    buffer_size_ = x_->image_size();
+  else if (buffer_size_ < x_->image_size())
+  {
+    LOG(ERROR) << "Image larger than buffer";
+    return false;
+  }
+
+  if (!base::SharedMemory::IsHandleValid(shm_->handle()))
+  {
+    if (!shm_->CreateAnonymous(buffer_size_))
+    {
+      LOG(ERROR) << "Failed to create anon shm: size=" << x_->image_size();
+      return false;
+    }
+  }
+
+  if (!x_->attach_smh(shm_->handle()))
+  {
+    x_ = nullptr;
+    return false;
+  }
+
+  return true;
+}
+
+std::unique_ptr<XcbCookie>
+SharedImageX11::put_image(const Drawable drawable, const GC gc,
+                            const gfx::Rect& rect, const gfx::Rect& src_rect)
+{
+  return x_ == nullptr ? nullptr :
+    x_->put_image(drawable, XGContextFromGC(gc), rect, src_rect);
+}
+
+size_t
+SharedImageX11::stride() const
+{
+  return x_ == nullptr ? 0 : x_->stride();
+}
+
+void *
+SharedImageX11::memory() const
+{
+  void * v = shm_->memory();
+  if (v != nullptr)
+    return v;
+  if (buffer_size_ == 0)
+  {
+    LOG(ERROR) << __func__ << ": No buffer size";
+    return nullptr;
+  }
+  if (!shm_->Map(buffer_size_))
+  {
+    LOG(ERROR) << __func__ << ": Map failed: size=" << buffer_size_;
+    return nullptr;
+  }
+  return shm_->memory();
+}
+
+}  // namespace viz
+
+#else
+
+namespace viz {
+
+// *** Stub for when we have no xcb-image
+//     For unknown reasons we end up compiling this for x86 without the expected lib
+
+class SharedImageX11::X
+{
+public:
+  X() {}
+
+  ~X() {}
+};
+
+SharedImageX11::SharedImageX11(std::unique_ptr<base::SharedMemory>&& shm) :
+  stride_(0),
+  buffer_size_(0)
+{
+}
+
+SharedImageX11::SharedImageX11(const base::SharedMemoryHandle& shmh, const bool ro) :
+  stride_(0),
+  buffer_size_(0)
+{
+}
+
+SharedImageX11::SharedImageX11() :
+  stride_(0),
+  buffer_size_(0)
+{
+}
+
+SharedImageX11::~SharedImageX11()
+{
+}
+
+// Check if the X Shared Memory extension is available.
+bool
+SharedImageX11::check_support(Display *const display)
+{
+  return false;
+}
+
+bool
+SharedImageX11::create_image(XDisplay * const display, const XWindowAttributes& attributes)
+{
+  return false;
+}
+
+std::unique_ptr<XcbCookie>
+SharedImageX11::put_image(const Drawable drawable, const GC gc,
+                            const gfx::Rect& rect, const gfx::Rect& src_rect)
+{
+  return nullptr;
+}
+
+size_t
+SharedImageX11::stride() const
+{
+  return 0;
+}
+
+void *
+SharedImageX11::memory() const
+{
+  return nullptr;
+}
+
+}  // namespace viz
+
+
+#endif
+
+
+
+
Index: chromium-browser-65.0.3325.181/components/viz/common/resources/shared_image_x11.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/common/resources/shared_image_x11.h
@@ -0,0 +1,63 @@
+#ifndef VIZ_RESOURCES_SHARED_IMAGE_X11_H_
+#define VIZ_RESOURCES_SHARED_IMAGE_X11_H_
+
+#include "base/memory/shared_memory.h"
+#include "components/viz/common/viz_common_export.h"
+#include "ui/gfx/x/x11_types.h"
+#include "ui/base/x/x11_util_internal.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace viz
+{
+
+class VIZ_COMMON_EXPORT XcbCookie
+{
+public:
+  virtual ~XcbCookie() {};
+  virtual bool sync() = 0;
+};
+
+class VIZ_COMMON_EXPORT SharedImageX11
+{
+  class X;
+
+  const std::unique_ptr<base::SharedMemory> shm_;
+
+  // Hide all the X shm stuff so we don't have to include the X libs
+  // which conflict with a number standard defs.
+  std::unique_ptr<X> x_;
+  size_t stride_;
+  gfx::Size size_;
+  size_t buffer_size_;
+
+public:
+  SharedImageX11(std::unique_ptr<base::SharedMemory>&& shm); // Can move a shm pointer into this
+  SharedImageX11(const base::SharedMemoryHandle& shmh, const bool ro = false);
+  SharedImageX11();
+  ~SharedImageX11();
+  void set_buffer_size(const size_t buffer_size) {
+    buffer_size_ = buffer_size;
+  }
+  void set_size(const gfx::Size& size, const size_t stride) {
+    stride_ = stride;
+    size_ = size;
+  }
+  const gfx::Size& get_size() const {
+    return size_;
+  }
+
+  static bool check_support(XDisplay * const display);
+  bool create_image(XDisplay * const display, const XWindowAttributes& attributes);
+  std::unique_ptr<XcbCookie> put_image(const Drawable drawable, const GC gc,
+                 const gfx::Rect& rect, const gfx::Rect& src_rect);
+
+  size_t stride() const;
+  void * memory() const;
+};
+
+}  // namespace viz
+
+#endif
+
+
+
Index: chromium-browser-65.0.3325.181/components/viz/common/resources/transferable_resource.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/common/resources/transferable_resource.h
+++ chromium-browser-65.0.3325.181/components/viz/common/resources/transferable_resource.h
@@ -92,6 +92,9 @@ struct VIZ_COMMON_EXPORT TransferableRes
   // and may be unset.
   gfx::Size size;
 
+  // (Pi) Stride for frame resource
+  uint32_t stride = 0;
+
   // The format of the pixels in the gpu mailbox/software bitmap. This should
   // almost always be RGBA_8888 for resources generted by compositor clients,
   // and must be RGBA_8888 always for software resources.
@@ -141,6 +144,7 @@ struct VIZ_COMMON_EXPORT TransferableRes
     return id == o.id && format == o.format &&
            buffer_format == o.buffer_format && filter == o.filter &&
            size == o.size &&
+           stride == o.stride &&
            mailbox_holder.mailbox == o.mailbox_holder.mailbox &&
            mailbox_holder.sync_token == o.mailbox_holder.sync_token &&
            mailbox_holder.texture_target == o.mailbox_holder.texture_target &&
Index: chromium-browser-65.0.3325.181/components/viz/service/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/BUILD.gn
+++ chromium-browser-65.0.3325.181/components/viz/service/BUILD.gn
@@ -54,6 +54,8 @@ viz_component("service") {
     "display/overlay_strategy_fullscreen.h",
     "display/overlay_strategy_single_on_top.cc",
     "display/overlay_strategy_single_on_top.h",
+    "display/overlay_strategy_single_shmid.cc",
+    "display/overlay_strategy_single_shmid.h",
     "display/overlay_strategy_underlay.cc",
     "display/overlay_strategy_underlay.h",
     "display/overlay_strategy_underlay_cast.cc",
@@ -253,6 +255,13 @@ viz_component("service") {
   if (enable_vulkan) {
     deps += [ "//gpu/vulkan" ]
   }
+
+  if (use_x11) {
+    sources += [
+      "display_embedder/compositor_overlay_candidate_validator_x_shm.cc",
+      "display_embedder/compositor_overlay_candidate_validator_x_shm.h",
+    ]
+  }
 }
 
 viz_source_set("unit_tests") {
Index: chromium-browser-65.0.3325.181/components/viz/service/display/overlay_strategy_single_shmid.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/service/display/overlay_strategy_single_shmid.cc
@@ -0,0 +1,113 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/viz/service/display/overlay_strategy_single_shmid.h"
+
+#include "components/viz/service/display/overlay_candidate_validator.h"
+#include "cc/base/math_util.h"
+#include "cc/resources/display_resource_provider.h"
+#include "components/viz/common/quads/draw_quad.h"
+#include "components/viz/common/resources/shared_image_x11.h"
+#include "ui/gfx/geometry/rect_conversions.h"
+
+namespace viz {
+
+OverlayStrategySingleShmid::OverlayStrategySingleShmid(
+    OverlayCandidateValidator* capability_checker)
+    : capability_checker_(capability_checker) {
+  DCHECK(capability_checker);
+}
+
+OverlayStrategySingleShmid::~OverlayStrategySingleShmid() {}
+
+bool OverlayStrategySingleShmid::Attempt(const SkMatrix44& output_color_matrix,
+                                         cc::DisplayResourceProvider* resource_provider,
+                                         RenderPass* render_pass,
+                                         cc::OverlayCandidateList* candidate_list,
+                                         std::vector<gfx::Rect>* content_bounds)
+{
+  QuadList* quad_list = &render_pass->quad_list;
+  for (auto it = quad_list->begin(); it != quad_list->end(); ++it) {
+    cc::OverlayCandidate candidate;
+
+    if (it->material != DrawQuad::Material::TEXTURE_CONTENT)
+        continue;
+
+    if (!cc::OverlayCandidate::FromDrawQuad(resource_provider, output_color_matrix, *it, &candidate))
+      continue;
+
+    cc::DisplayResourceProvider::ScopedReadLockSharedImageX11 lock(resource_provider, candidate.resource_id);
+
+    if (!lock.valid())
+      continue;
+
+    viz::SharedImageX11 * const xshm = lock.shared_image_x11();
+#if 0
+    const OverlayCandidate& x = candidate;
+
+    LOG(ERROR) << "Got candidate id=" << x.resource_id <<
+      ", is_opaque=" << x.is_opaque <<
+      ", use_resource=" << x.use_output_surface_for_resource <<
+      ", display_rect=" << x.display_rect.ToString() <<
+      ", pixels=" << x.resource_size_in_pixels.ToString() <<
+      ", uv_rect=" << x.uv_rect.ToString() <<
+      ", quad_rect_in_target_space=" << x.quad_rect_in_target_space.ToString() <<
+      ", clip_rect=" << x.clip_rect.ToString() <<
+      ", z=" << x.plane_z_order <<
+      ", src_size=" << xshm->get_size().ToString() <<
+      ", pass damage=" << render_pass->damage_rect.ToString();
+#endif
+
+    const gfx::Rect cand_rect(gfx::ToEnclosingRect(candidate.display_rect));
+
+    if (xshm->get_size() != cand_rect.size()) {
+//      LOG(ERROR) << "Size mismatch " << xshm->get_size().ToString() << "/" << cand_rect.size().ToString();
+      continue;
+    }
+
+    // Check we cover the damage rect
+    if (!cand_rect.Contains(render_pass->damage_rect)) {
+//      LOG(ERROR) << "Damage exceeds texture " << cand_rect.ToString() << "/" << render_pass->damage_rect.ToString();
+      continue;
+    }
+
+    if (TryOverlay(quad_list, candidate_list, candidate, it)) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool OverlayStrategySingleShmid::TryOverlay(
+    QuadList* quad_list,
+    cc::OverlayCandidateList* candidate_list,
+    const cc::OverlayCandidate& candidate,
+    QuadList::Iterator candidate_iterator) {
+  // Check that no prior quads overlap it.
+  if (cc::OverlayCandidate::IsOccluded(candidate, quad_list->cbegin(),
+                                   candidate_iterator))
+      return false;
+
+  // Add the overlay.
+  cc::OverlayCandidateList new_candidate_list = *candidate_list;
+  new_candidate_list.push_back(candidate);
+  new_candidate_list.back().plane_z_order = 1;
+
+  // Check for support.
+  capability_checker_->CheckOverlaySupport(&new_candidate_list);
+
+  const cc::OverlayCandidate& overlay_candidate = new_candidate_list.back();
+  // If the candidate can be handled by an overlay, create a pass for it.
+  if (overlay_candidate.overlay_handled) {
+    quad_list->EraseAndInvalidateAllPointers(candidate_iterator);
+    candidate_list->swap(new_candidate_list);
+    return true;
+  }
+
+  return false;
+}
+
+}  // namespace cc
+
Index: chromium-browser-65.0.3325.181/components/viz/service/display/overlay_strategy_single_shmid.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/service/display/overlay_strategy_single_shmid.h
@@ -0,0 +1,42 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VIZ_SERVICE_DISPLAY_OVERLAY_STRATEGY_SINGLE_SHMID_H_
+#define VIZ_SERVICE_DISPLAY_OVERLAY_STRATEGY_SINGLE_SHMID_H_
+
+#include "base/macros.h"
+#include "components/viz/service/display/overlay_processor.h"
+#include "components/viz/service/viz_service_export.h"
+
+namespace viz {
+
+class OverlayCandidateValidator;
+
+class VIZ_SERVICE_EXPORT OverlayStrategySingleShmid : public OverlayProcessor::Strategy {
+ public:
+  explicit OverlayStrategySingleShmid(
+      OverlayCandidateValidator* capability_checker);
+  ~OverlayStrategySingleShmid() override;
+
+  bool Attempt(const SkMatrix44& output_color_matrix,
+               cc::DisplayResourceProvider* resource_provider,
+               RenderPass* render_pass,
+               cc::OverlayCandidateList* candidate_list,
+               std::vector<gfx::Rect>* content_bounds) override;
+
+ private:
+   bool TryOverlay(QuadList* quad_list,
+                   cc::OverlayCandidateList* candidate_list,
+                   const cc::OverlayCandidate& candidate,
+                   QuadList::Iterator candidate_iterator);
+
+  OverlayCandidateValidator* capability_checker_;  // Weak.
+
+  DISALLOW_COPY_AND_ASSIGN(OverlayStrategySingleShmid);
+};
+
+}  // namespace viz
+
+#endif  // VIZ_SERVICE_DISPLAY_OVERLAY_STRATEGY_SINGLE_SHMID_H__
+
Index: chromium-browser-65.0.3325.181/components/viz/service/display/software_output_device.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display/software_output_device.cc
+++ chromium-browser-65.0.3325.181/components/viz/service/display/software_output_device.cc
@@ -32,6 +32,14 @@ SkCanvas* SoftwareOutputDevice::BeginPai
 
 void SoftwareOutputDevice::EndPaint() {}
 
+void SoftwareOutputDevice::EndPaint(const gfx::Rect& damage_rect,
+  cc::DisplayResourceProvider * const resource_provider,
+  const cc::OverlayCandidateList& overlay_list)
+{
+    // By default ignore the extra info
+    EndPaint();
+}
+
 gfx::VSyncProvider* SoftwareOutputDevice::GetVSyncProvider() {
   return vsync_provider_.get();
 }
Index: chromium-browser-65.0.3325.181/components/viz/service/display/software_output_device.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display/software_output_device.h
+++ chromium-browser-65.0.3325.181/components/viz/service/display/software_output_device.h
@@ -16,6 +16,11 @@
 
 class SkCanvas;
 
+namespace cc {
+class OverlayCandidateList;
+class DisplayResourceProvider;
+}
+
 namespace gfx {
 class VSyncProvider;
 }
@@ -45,7 +50,11 @@ class VIZ_SERVICE_EXPORT SoftwareOutputD
   // that it holds to it.
   virtual void EndPaint();
 
-  // Discard the backing buffer in the surface provided by this instance.
+  virtual void EndPaint(const gfx::Rect& damage_rect,
+      cc::DisplayResourceProvider * const resource_provider,
+      const cc::OverlayCandidateList& overlay_list);
+
+   // Discard the backing buffer in the surface provided by this instance.
   virtual void DiscardBackbuffer() {}
 
   // Ensures that there is a backing buffer available on this instance.
Index: chromium-browser-65.0.3325.181/components/viz/service/display/software_renderer.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display/software_renderer.cc
+++ chromium-browser-65.0.3325.181/components/viz/service/display/software_renderer.cc
@@ -63,7 +63,8 @@ void SoftwareRenderer::FinishDrawingFram
   current_canvas_ = nullptr;
   root_canvas_ = nullptr;
 
-  output_device_->EndPaint();
+  DrawingFrame * const frame = current_frame();
+  output_device_->EndPaint(frame->root_damage_rect, resource_provider_, frame->overlay_list);
 }
 
 void SoftwareRenderer::SwapBuffers(std::vector<ui::LatencyInfo> latency_info) {
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/compositor_overlay_candidate_validator_x_shm.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/compositor_overlay_candidate_validator_x_shm.cc
@@ -0,0 +1,64 @@
+#include "components/viz/service/display_embedder/compositor_overlay_candidate_validator_x_shm.h"
+
+#include "base/memory/ptr_util.h"
+#include "components/viz/service/display/overlay_processor.h"
+#include "components/viz/service/display/overlay_strategy_single_shmid.h"
+
+
+namespace viz {
+
+CompositorOverlayCandidateValidatorXShm::CompositorOverlayCandidateValidatorXShm(const bool use_shm) :
+  use_shm_(use_shm)
+{
+}
+
+CompositorOverlayCandidateValidatorXShm::~CompositorOverlayCandidateValidatorXShm()
+{
+}
+
+void
+CompositorOverlayCandidateValidatorXShm::SetSoftwareMirrorMode(bool enabled)
+{
+// *** NIF
+}
+
+// Populates a list of strategies that may work with this validator.
+void
+CompositorOverlayCandidateValidatorXShm::GetStrategies(OverlayProcessor::StrategyList* strategies)
+{
+  if (use_shm_) {
+    strategies->push_back(base::MakeUnique<OverlayStrategySingleShmid>(this));
+  }
+}
+
+// Returns ??
+bool
+CompositorOverlayCandidateValidatorXShm::AllowDCLayerOverlays()
+{
+  return false;
+}
+
+// Returns true if draw quads can be represented as CALayers (Mac only).
+bool
+CompositorOverlayCandidateValidatorXShm::AllowCALayerOverlays()
+{
+  return false;
+}
+
+// A list of possible overlay candidates is presented to this function.
+// The expected result is that those candidates that can be in a separate
+// plane are marked with |overlay_handled| set to true, otherwise they are
+// to be traditionally composited. Candidates with |overlay_handled| set to
+// true must also have their |display_rect| converted to integer
+// coordinates if necessary.
+void
+CompositorOverlayCandidateValidatorXShm::CheckOverlaySupport(cc::OverlayCandidateList* surfaces)
+{
+  // Accept if we have shm support
+  for (auto& x: *surfaces) {
+    x.overlay_handled = use_shm_;
+  }
+}
+
+} // namespace display_compositor
+
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/compositor_overlay_candidate_validator_x_shm.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/compositor_overlay_candidate_validator_x_shm.h
@@ -0,0 +1,40 @@
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VIZ_SERVICE_DISPLAY_EMBEDDER_COMPOSITOR_OVERLAY_CANDIDATE_VALIDATOR_X_SHM_H_
+#define VIZ_SERVICE_DISPLAY_EMBEDDER_COMPOSITOR_OVERLAY_CANDIDATE_VALIDATOR_X_SHM_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "components/viz/service/display_embedder/compositor_overlay_candidate_validator.h"
+#include "components/viz/service/viz_service_export.h"
+
+namespace viz {
+
+class VIZ_SERVICE_EXPORT CompositorOverlayCandidateValidatorXShm
+    : public CompositorOverlayCandidateValidator {
+ public:
+  explicit CompositorOverlayCandidateValidatorXShm(const bool use_shm);
+  ~CompositorOverlayCandidateValidatorXShm() override;
+
+  // cc::OverlayCandidateValidator implementation.
+  void GetStrategies(OverlayProcessor::StrategyList* strategies) override;
+  bool AllowCALayerOverlays() override;
+  bool AllowDCLayerOverlays() override;
+  void CheckOverlaySupport(cc::OverlayCandidateList* surfaces) override;
+
+  // CompositorOverlayCandidateValidator implementation.
+  void SetSoftwareMirrorMode(bool enabled) override;
+
+ private:
+  const bool use_shm_;
+
+  DISALLOW_COPY_AND_ASSIGN(CompositorOverlayCandidateValidatorXShm);
+};
+
+}  // namespace display_compositor
+
+#endif  // COMPONENTS_DISPLAY_COMPOSITOR_COMPOSITOR_OVERLAY_CANDIDATE_VALIDATOR_X_SHM_H_
+
+
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/server_shared_bitmap_manager.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display_embedder/server_shared_bitmap_manager.cc
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/server_shared_bitmap_manager.cc
@@ -16,13 +16,20 @@
 #include "base/trace_event/process_memory_dump.h"
 #include "ui/gfx/geometry/size.h"
 
+#include "media/base/video_frame.h"
+#include "components/viz/common/quads/shared_bitmap.h"
+#include "components/viz/common/resources/shared_image_x11.h"
+
+
 namespace viz {
 
 class BitmapData : public base::RefCountedThreadSafe<BitmapData> {
  public:
   explicit BitmapData(size_t buffer_size) : buffer_size(buffer_size) {}
   std::unique_ptr<base::SharedMemory> memory;
+  std::unique_ptr<SharedImageX11> xshm;
   std::unique_ptr<uint8_t[]> pixels;
+  scoped_refptr<media::VideoFrame> frame;
   size_t buffer_size;
 
  private:
@@ -93,6 +100,27 @@ std::unique_ptr<SharedBitmap> ServerShar
                                               this);
 }
 
+std::unique_ptr<SharedBitmap> ServerSharedBitmapManager::AllocateSharedFrame(
+    const scoped_refptr<media::VideoFrame>& video_frame) {
+  base::AutoLock lock(lock_);
+
+  size_t bitmap_size = video_frame->rows(0) * video_frame->row_bytes(0);
+  SharedBitmap::SizeInBytes(video_frame->coded_size(), &bitmap_size);
+
+  scoped_refptr<BitmapData> data(new BitmapData(bitmap_size));
+
+  // Bitmaps allocated in host don't need to be shared to other processes, so
+  // allocate them with new instead.
+  data->frame = video_frame;
+
+  SharedBitmapId id = SharedBitmap::GenerateId();
+
+//  LOG(ERROR) << "ServerSharedBitmapManager::AllocateSharedFrame, size=" << data->buffer_size << ", id=" << SharedBitmap::hashid(id);
+
+  handle_map_[id] = data;
+  return std::make_unique<ServerSharedBitmap>(data->pixels.get(), data, id, this);
+}
+
 std::unique_ptr<SharedBitmap> ServerSharedBitmapManager::GetSharedBitmapFromId(
     const gfx::Size& size,
     const SharedBitmapId& id) {
@@ -112,12 +140,41 @@ std::unique_ptr<SharedBitmap> ServerShar
     return std::make_unique<ServerSharedBitmap>(data->pixels.get(), data, id,
                                                 nullptr);
   }
-  if (!data->memory->memory()) {
-    return nullptr;
+  else if (data->frame != nullptr) {
+    return std::make_unique<ServerSharedBitmap>(data->frame->data(0), data, id,
+                                              nullptr);
   }
+  else if (data->memory) {
+    if (!data->memory->memory()) {
+      return std::unique_ptr<SharedBitmap>();
+    }
 
-  return std::make_unique<ServerSharedBitmap>(
-      static_cast<uint8_t*>(data->memory->memory()), data, id, nullptr);
+    return std::make_unique<ServerSharedBitmap>(
+        static_cast<uint8_t*>(data->memory->memory()), data, id, nullptr);
+  }
+  else
+  {
+    if (!data->xshm->memory()) {
+      return std::unique_ptr<SharedBitmap>();
+    }
+    return std::make_unique<ServerSharedBitmap>(
+        static_cast<uint8_t*>(data->xshm->memory()), data, id, nullptr);
+  }
+}
+
+SharedImageX11 *
+ServerSharedBitmapManager::GetSharedImageX11ForBitmap(const SharedBitmapId& id)
+{
+  base::AutoLock lock(lock_);
+  auto it = handle_map_.find(id);
+  if (it == handle_map_.end())
+    return nullptr;
+
+  // It is possible to convert an ordinary shared memory segment to an
+  // image here - but it might have unforseen consequnces so stick with
+  // only dealing with things that started off as images
+
+  return it->second->xshm.get();
 }
 
 bool ServerSharedBitmapManager::OnMemoryDump(
@@ -160,14 +217,24 @@ bool ServerSharedBitmapManager::OnMemory
 bool ServerSharedBitmapManager::ChildAllocatedSharedBitmap(
     size_t buffer_size,
     const base::SharedMemoryHandle& handle,
-    const SharedBitmapId& id) {
+    const SharedBitmapId& id,
+    bool is_image) {
   base::AutoLock lock(lock_);
   if (handle_map_.find(id) != handle_map_.end())
     return false;
   auto data = base::MakeRefCounted<BitmapData>(buffer_size);
-  data->memory = std::make_unique<base::SharedMemory>(handle, false);
-  data->memory->Map(data->buffer_size);
-  data->memory->Close();
+
+  if (is_image) {
+    data->xshm = std::make_unique<SharedImageX11>(handle, true);
+    data->xshm->set_buffer_size(data->buffer_size);
+  }
+  else
+  {
+    data->memory = std::make_unique<base::SharedMemory>(handle, false);
+    data->memory->Map(data->buffer_size);
+    data->memory->Close();
+  }
+
   handle_map_[id] = std::move(data);
   return true;
 }
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/server_shared_bitmap_manager.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display_embedder/server_shared_bitmap_manager.h
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/server_shared_bitmap_manager.h
@@ -41,6 +41,12 @@ class VIZ_SERVICE_EXPORT ServerSharedBit
       const gfx::Size& size,
       const SharedBitmapId&) override;
 
+  std::unique_ptr<SharedBitmap> AllocateSharedFrame(
+      const scoped_refptr<media::VideoFrame>& video_frame) override;
+
+  SharedImageX11 * GetSharedImageX11ForBitmap(
+      const SharedBitmapId& id) override;
+
   // base::trace_event::MemoryDumpProvider implementation.
   bool OnMemoryDump(const base::trace_event::MemoryDumpArgs& args,
                     base::trace_event::ProcessMemoryDump* pmd) override;
@@ -54,7 +60,8 @@ class VIZ_SERVICE_EXPORT ServerSharedBit
 
   bool ChildAllocatedSharedBitmap(size_t buffer_size,
                                   const base::SharedMemoryHandle& handle,
-                                  const SharedBitmapId& id);
+                                  const SharedBitmapId& id,
+                                  bool is_image);
   void ChildDeletedSharedBitmap(const SharedBitmapId& id);
 
   mutable base::Lock lock_;
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/shared_bitmap_allocation_notifier_impl.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display_embedder/shared_bitmap_allocation_notifier_impl.cc
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/shared_bitmap_allocation_notifier_impl.cc
@@ -33,14 +33,15 @@ void SharedBitmapAllocationNotifierImpl:
 
 void SharedBitmapAllocationNotifierImpl::DidAllocateSharedBitmap(
     mojo::ScopedSharedBufferHandle buffer,
-    const SharedBitmapId& id) {
+    const SharedBitmapId& id,
+    bool is_image) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   base::SharedMemoryHandle memory_handle;
   size_t size;
   MojoResult result = mojo::UnwrapSharedMemoryHandle(
       std::move(buffer), &memory_handle, &size, nullptr);
   DCHECK_EQ(result, MOJO_RESULT_OK);
-  this->ChildAllocatedSharedBitmap(size, memory_handle, id);
+  this->ChildAllocatedSharedBitmap(size, memory_handle, id, is_image);
   last_sequence_number_++;
   for (SharedBitmapAllocationObserver& observer : observers_)
     observer.DidAllocateSharedBitmap(last_sequence_number_);
@@ -56,9 +57,10 @@ void SharedBitmapAllocationNotifierImpl:
 void SharedBitmapAllocationNotifierImpl::ChildAllocatedSharedBitmap(
     size_t buffer_size,
     const base::SharedMemoryHandle& handle,
-    const SharedBitmapId& id) {
+    const SharedBitmapId& id,
+    bool is_image) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  if (manager_->ChildAllocatedSharedBitmap(buffer_size, handle, id))
+  if (manager_->ChildAllocatedSharedBitmap(buffer_size, handle, id, is_image))
     owned_bitmaps_.insert(id);
 }
 
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/shared_bitmap_allocation_notifier_impl.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display_embedder/shared_bitmap_allocation_notifier_impl.h
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/shared_bitmap_allocation_notifier_impl.h
@@ -37,12 +37,14 @@ class VIZ_SERVICE_EXPORT SharedBitmapAll
 
   // mojom::SharedBitmapAllocationNotifier overrides:
   void DidAllocateSharedBitmap(mojo::ScopedSharedBufferHandle buffer,
-                               const SharedBitmapId& id) override;
+                               const SharedBitmapId& id,
+                               bool is_image) override;
   void DidDeleteSharedBitmap(const SharedBitmapId& id) override;
 
   void ChildAllocatedSharedBitmap(size_t buffer_size,
                                   const base::SharedMemoryHandle& handle,
-                                  const SharedBitmapId& id);
+                                  const SharedBitmapId& id,
+                                  bool is_image);
 
   void ChildDied();
 
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/software_output_device_x11.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display_embedder/software_output_device_x11.cc
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/software_output_device_x11.cc
@@ -8,16 +8,85 @@
 #include <stdint.h>
 #include <string.h>
 
+#include "cc/resources/display_resource_provider.h"
+#include "components/viz/common/resources/shared_image_x11.h"
 #include "third_party/skia/include/core/SkImageInfo.h"
 #include "ui/base/x/x11_util.h"
 #include "ui/base/x/x11_util_internal.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/gfx/x/x11_types.h"
+#include "ui/gfx/geometry/rect_conversions.h"
 
 namespace viz {
 
+int
+SoftwareOutputDeviceX11::ShmDesc::attach(XDisplay * const display,
+  const XWindowAttributes& attributes, const int w, const int h)
+{
+  // Clear out old allocation
+  xshm_ = nullptr;
+
+  std::unique_ptr<viz::SharedImageX11> xshm(base::MakeUnique<viz::SharedImageX11>());
+
+  // Set size to requested (min)w x h; let the code pick stride
+  xshm->set_size(gfx::Size(w, h), 0);
+
+  if (!xshm->create_image(display, attributes))
+      return -1;
+
+  xshm_ = std::move(xshm);
+  return 0;
+}
+
+std::unique_ptr<viz::XcbCookie> SoftwareOutputDeviceX11::ShmDesc::put_image(Drawable drawable, GC gc, const gfx::Rect& rect)
+{
+  return xshm_->put_image(drawable, gc, rect, rect);
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::resize(const SkImageInfo& info)
+{
+//  LOG(ERROR) << "resize req:" << info.width() << "x" << info.height();
+  req_ii_ = info;
+}
+
+sk_sp<SkSurface>
+SoftwareOutputDeviceX11::ShmDesc::use_surface(XDisplay * const display, const XWindowAttributes& attributes)
+{
+  if (req_ii_ != cur_ii_) {
+//    LOG(ERROR) << "resize set:" << req_ii_.width() << "x" << req_ii_.height();
+
+    // Kill all current stuff
+    surface_.reset();
+
+    // Rebuild
+    if (attach(display, attributes, req_ii_.minRowBytes()/req_ii_.bytesPerPixel(), req_ii_.height()) != 0)
+    {
+      LOG(ERROR) << "Failed to make new XImage";
+    }
+    // Build a surface on it
+    else if (!(surface_ = SkSurface::MakeRasterDirect(req_ii_, xshm_->memory(), xshm_->stride())))
+    {
+      LOG(ERROR) << "Failed to make new SkSurface";
+    }
+    else
+    {
+      // Success
+      cur_ii_ = req_ii_;
+    }
+  }
+  return surface_;
+}
+
+
+SoftwareOutputDeviceX11::ShmDesc::ShmDesc() {
+}
+
+SoftwareOutputDeviceX11::ShmDesc::~ShmDesc() {
+}
+
+
 SoftwareOutputDeviceX11::SoftwareOutputDeviceX11(gfx::AcceleratedWidget widget)
-    : widget_(widget), display_(gfx::GetXDisplay()), gc_(nullptr) {
+    : widget_(widget), display_(gfx::GetXDisplay()), gc_(nullptr), shm_n_(0) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
   gc_ = XCreateGC(display_, widget_, 0, nullptr);
@@ -25,14 +94,68 @@ SoftwareOutputDeviceX11::SoftwareOutputD
     LOG(ERROR) << "XGetWindowAttributes failed for window " << widget_;
     return;
   }
+
+  if (!(gfx::BitsPerPixelForPixmapDepth(display_, attributes_.depth) == 32 &&
+        attributes_.visual->red_mask == 0xff0000 &&
+        attributes_.visual->green_mask == 0xff00 &&
+        attributes_.visual->blue_mask == 0xff &&
+        viz::SharedImageX11::check_support(display_)))
+  {
+    LOG(WARNING) << "Display attributes incompatible with SHM";
+    shm_n_ = -1;
+  }
+  else
+  {
+    for (int i = 0; i != 2; ++i) {
+      // Pick any old initial shape - it will be freed as soon as we start
+      // know what size we actually want (even if it is 1024x768!)
+      // This also allows us to check here that SHM actually works
+      if (shm_descs_[i].attach(display_, attributes_, 1024, 768) != 0)
+      {
+        shm_n_ = -1;
+        break;
+      }
+    }
+  }
 }
 
 SoftwareOutputDeviceX11::~SoftwareOutputDeviceX11() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
+  overlay_lock_.release();  // **** Kludge to avoid shutdown crash
   XFreeGC(display_, gc_);
 }
 
+bool SoftwareOutputDeviceX11::use_shm() const
+{
+  return shm_n_ >= 0;
+}
+
+void SoftwareOutputDeviceX11::Resize(const gfx::Size& viewport_pixel_size,
+                                  float scale_factor) {
+//  scale_factor_ = scale_factor;
+
+  if (viewport_pixel_size_ == viewport_pixel_size)
+    return;
+
+  const SkImageInfo info(SkImageInfo::MakeN32(viewport_pixel_size.width(),
+                                          viewport_pixel_size.height(),
+                                          kOpaque_SkAlphaType));
+  viewport_pixel_size_ = viewport_pixel_size;
+
+  if (shm_n_ < 0) {
+    surface_ = SkSurface::MakeRaster(info);
+  }
+  else
+  {
+    for (int i = 0; i != 2; ++i) {
+      shm_descs_[i].resize(info);
+    }
+
+    surface_ = shm_descs_[shm_n_].use_surface(display_, attributes_);
+  }
+}
+
 void SoftwareOutputDeviceX11::EndPaint() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
@@ -106,11 +229,64 @@ void SoftwareOutputDeviceX11::EndPaint()
   // TODO(jbauman): Switch to XShmPutImage since it's async.
   SkPixmap pixmap;
   surface_->peekPixels(&pixmap);
-  gfx::PutARGBImage(display_, attributes_.visual, attributes_.depth, widget_,
-                    gc_, static_cast<const uint8_t*>(pixmap.addr()),
-                    viewport_pixel_size_.width(), viewport_pixel_size_.height(),
-                    rect.x(), rect.y(), rect.x(), rect.y(), rect.width(),
-                    rect.height());
+
+  if (shm_n_ >= 0) {
+    last_cookie_ = shm_descs_[shm_n_].put_image(widget_, static_cast<GC>(gc_), rect);
+    // Swap to other surface for next draw
+    // Could use sync if we only want 1 surface but that wastes time
+    //  XSync(display_, false);
+    shm_n_ = (shm_n_ + 1) % 2;
+    surface_ = shm_descs_[shm_n_].use_surface(display_, attributes_);
+  }
+  else
+  {
+    gfx::PutARGBImage(display_, attributes_.visual, attributes_.depth, widget_,
+                      gc_, static_cast<const uint8_t*>(pixmap.addr()),
+                      viewport_pixel_size_.width(), viewport_pixel_size_.height(),
+                      rect.x(), rect.y(), rect.x(), rect.y(), rect.width(),
+                      rect.height());
+  }
 }
 
+void SoftwareOutputDeviceX11::EndPaint(const gfx::Rect& damage_rect,
+  cc::DisplayResourceProvider * const resource_provider,
+  const cc::OverlayCandidateList& overlay_list)
+{
+  // Release these locks at end of func - but allow reassignment before then
+  const std::unique_ptr<cc::DisplayResourceProvider::ScopedReadLockSharedImageX11> lock(overlay_lock_.release());
+  // Ordering means sync will be released (on destruction) before overlay lock
+  const std::unique_ptr<viz::XcbCookie> sync_cookie(last_cookie_.release());
+
+  damage_rect_ = damage_rect;
+  EndPaint();
+
+  for (const cc::OverlayCandidate& ovly : overlay_list ) {
+    if (ovly.overlay_handled) {
+      if (!damage_rect.IsEmpty()) {
+        LOG(ERROR) << "Damage rect not empty: " << damage_rect.ToString();
+      }
+
+      overlay_lock_ = base::MakeUnique<cc::DisplayResourceProvider::ScopedReadLockSharedImageX11>(
+          resource_provider, ovly.resource_id);
+
+      viz::SharedImageX11 *const xshm = overlay_lock_->shared_image_x11();
+      if (xshm == nullptr){
+        LOG(ERROR) << "SharedMemory unexpectly null";
+        continue;
+      }
+
+      const gfx::Rect rect(gfx::ToEnclosingRect(ovly.display_rect));
+
+      if (!xshm->create_image(display_, attributes_))
+      {
+          LOG(ERROR) << "xshm.create_image failed!";
+          continue;
+      }
+
+      last_cookie_ = xshm->put_image(widget_, gc_, rect, gfx::Rect());
+    }
+  }
+}
+
+
 }  // namespace viz
Index: chromium-browser-65.0.3325.181/components/viz/service/display_embedder/software_output_device_x11.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/display_embedder/software_output_device_x11.h
+++ chromium-browser-65.0.3325.181/components/viz/service/display_embedder/software_output_device_x11.h
@@ -5,6 +5,11 @@
 #ifndef COMPONENTS_VIZ_SERVICE_DISPLAY_EMBEDDER_SOFTWARE_OUTPUT_DEVICE_X11_H_
 #define COMPONENTS_VIZ_SERVICE_DISPLAY_EMBEDDER_SOFTWARE_OUTPUT_DEVICE_X11_H_
 
+#include <X11/Xlib.h>
+
+#include "cc/resources/display_resource_provider.h"
+#include "components/viz/common/resources/shared_image_x11.h"
+
 #include "base/macros.h"
 #include "base/threading/thread_checker.h"
 #include "components/viz/service/display/software_output_device.h"
@@ -21,15 +26,46 @@ class VIZ_SERVICE_EXPORT SoftwareOutputD
 
   ~SoftwareOutputDeviceX11() override;
 
+  void Resize(const gfx::Size& viewport_pixel_size, float scale_factor) override;
   void EndPaint() override;
+  void EndPaint(const gfx::Rect& damage_rect,
+      cc::DisplayResourceProvider * const resource_provider,
+      const cc::OverlayCandidateList& overlay_list) override;
+
+  bool use_shm() const;
 
  private:
   gfx::AcceleratedWidget widget_;
-  XDisplay* display_;
+  XDisplay* const display_;
   GC gc_;
   XWindowAttributes attributes_;
   THREAD_CHECKER(thread_checker_);
 
+  // Shared memory stuff
+
+  std::unique_ptr<cc::DisplayResourceProvider::ScopedReadLockSharedImageX11> overlay_lock_;
+  std::unique_ptr<viz::XcbCookie> last_cookie_;
+
+  int shm_n_;
+  class ShmDesc
+  {
+    sk_sp<SkSurface> surface_;
+    SkImageInfo req_ii_;
+    SkImageInfo cur_ii_;
+
+public:
+    std::unique_ptr<viz::SharedImageX11> xshm_;
+
+    ShmDesc();
+    virtual ~ShmDesc();
+    int attach(XDisplay * const display, const XWindowAttributes& attributes, const int stride, const int h);
+    void detach();
+    void destroy();
+    void resize(const SkImageInfo& info);
+    std::unique_ptr<viz::XcbCookie> put_image(Drawable drawable, GC gc, const gfx::Rect& rect);
+    sk_sp<SkSurface> use_surface(XDisplay * const display, const XWindowAttributes& attributes);
+  } shm_descs_[2];
+
   DISALLOW_COPY_AND_ASSIGN(SoftwareOutputDeviceX11);
 };
 
Index: chromium-browser-65.0.3325.181/components/viz/service/main/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/components/viz/service/main/BUILD.gn
+++ chromium-browser-65.0.3325.181/components/viz/service/main/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/ui.gni")
 import("//services/catalog/public/tools/catalog.gni")
 import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
+import("//build/config/sysroot.gni")
 
 source_set("main") {
   output_name = "viz_main_impl"
@@ -32,6 +33,12 @@ source_set("main") {
     "//ui/gl/init",
   ]
 
+    ldflags = [
+     "-L$sysroot/opt/vc/lib",
+     "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+     "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+    ]
+
   if (use_ozone) {
     deps += [ "//ui/ozone:ozone" ]
   }
Index: chromium-browser-65.0.3325.181/content/browser/browser_main_loop.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/browser_main_loop.cc
+++ chromium-browser-65.0.3325.181/content/browser/browser_main_loop.cc
@@ -662,7 +662,10 @@ int BrowserMainLoop::EarlyInitialization
 #endif
 
 #if defined(USE_X11)
-  if (UsingInProcessGpu()) {
+  // (Pi) The mmal shared memory passthrough requires MT X as the frame
+  // can be deleted (and detached) outside the display thread
+  if (1) {
+//  if (UsingInProcessGpu()) {
     if (!gfx::InitializeThreadedX11()) {
       LOG(ERROR) << "Failed to put Xlib into threaded mode.";
     }
Index: chromium-browser-65.0.3325.181/content/browser/compositor/browser_compositor_output_surface.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/compositor/browser_compositor_output_surface.cc
+++ chromium-browser-65.0.3325.181/content/browser/compositor/browser_compositor_output_surface.cc
@@ -20,6 +20,17 @@
 namespace content {
 
 BrowserCompositorOutputSurface::BrowserCompositorOutputSurface(
+    std::unique_ptr<viz::SoftwareOutputDevice> software_device,
+    const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
+    std::unique_ptr<viz::CompositorOverlayCandidateValidator>
+        overlay_candidate_validator)
+    : OutputSurface(std::move(software_device)),
+      update_vsync_parameters_callback_(update_vsync_parameters_callback),
+      reflector_(nullptr) {
+  overlay_candidate_validator_ = std::move(overlay_candidate_validator);
+}
+
+BrowserCompositorOutputSurface::BrowserCompositorOutputSurface(
     scoped_refptr<viz::ContextProvider> context_provider,
     const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
     std::unique_ptr<viz::CompositorOverlayCandidateValidator>
Index: chromium-browser-65.0.3325.181/content/browser/compositor/browser_compositor_output_surface.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/compositor/browser_compositor_output_surface.h
+++ chromium-browser-65.0.3325.181/content/browser/compositor/browser_compositor_output_surface.h
@@ -10,12 +10,10 @@
 #include "components/viz/service/display/output_surface.h"
 #include "content/common/content_export.h"
 
-namespace cc {
-class SoftwareOutputDevice;
-}
 
 namespace viz {
 class CompositorOverlayCandidateValidator;
+class SoftwareOutputDevice;
 }
 
 namespace gfx {
@@ -59,6 +57,11 @@ class CONTENT_EXPORT BrowserCompositorOu
   BrowserCompositorOutputSurface(
       std::unique_ptr<viz::SoftwareOutputDevice> software_device,
       const UpdateVSyncParametersCallback& update_vsync_parameters_callback);
+  BrowserCompositorOutputSurface(
+      std::unique_ptr<viz::SoftwareOutputDevice> software_device,
+      const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
+      std::unique_ptr<viz::CompositorOverlayCandidateValidator>
+          overlay_candidate_validator);
 
   // Constructor used by the Vulkan implementation.
   BrowserCompositorOutputSurface(
Index: chromium-browser-65.0.3325.181/content/browser/compositor/gpu_process_transport_factory.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/compositor/gpu_process_transport_factory.cc
+++ chromium-browser-65.0.3325.181/content/browser/compositor/gpu_process_transport_factory.cc
@@ -96,6 +96,7 @@
 #include "ui/ozone/public/surface_ozone_canvas.h"
 #elif defined(USE_X11)
 #include "components/viz/service/display_embedder/software_output_device_x11.h"
+#include "components/viz/service/display_embedder/compositor_overlay_candidate_validator_x_shm.h"
 #elif defined(OS_MACOSX)
 #include "components/viz/service/display_embedder/compositor_overlay_candidate_validator_mac.h"
 #include "components/viz/service/display_embedder/software_output_device_mac.h"
@@ -225,7 +226,8 @@ GpuProcessTransportFactory::~GpuProcessT
 
 std::unique_ptr<viz::SoftwareOutputDevice>
 GpuProcessTransportFactory::CreateSoftwareOutputDevice(
-    gfx::AcceleratedWidget widget) {
+    gfx::AcceleratedWidget widget, bool * const puse_shm) {
+  *puse_shm = false;
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kHeadless))
     return base::WrapUnique(new viz::SoftwareOutputDevice);
@@ -250,7 +252,9 @@ GpuProcessTransportFactory::CreateSoftwa
   return std::make_unique<viz::SoftwareOutputDeviceOzone>(
       std::move(surface_ozone));
 #elif defined(USE_X11)
-  return std::make_unique<viz::SoftwareOutputDeviceX11>(widget);
+  viz::SoftwareOutputDeviceX11 * const output_device = new viz::SoftwareOutputDeviceX11(widget);
+  *puse_shm = output_device->use_shm();
+  return std::unique_ptr<viz::SoftwareOutputDevice>(output_device);
 #elif defined(OS_MACOSX)
   return std::make_unique<viz::SoftwareOutputDeviceMac>(widget);
 #else
@@ -263,10 +267,11 @@ std::unique_ptr<viz::CompositorOverlayCa
 CreateOverlayCandidateValidator(
 #if defined(OS_MACOSX)
     gfx::AcceleratedWidget widget,
-    bool disable_overlay_ca_layers) {
+    bool disable_overlay_ca_layers,
 #else
-    gfx::AcceleratedWidget widget) {
+    gfx::AcceleratedWidget widget,
 #endif
+    const bool use_shm) {
   std::unique_ptr<viz::CompositorOverlayCandidateValidator> validator;
 #if defined(USE_OZONE)
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
@@ -294,6 +299,8 @@ CreateOverlayCandidateValidator(
   validator.reset(new viz::CompositorOverlayCandidateValidatorAndroid());
 #elif defined(OS_WIN)
   validator = std::make_unique<viz::CompositorOverlayCandidateValidatorWin>();
+#elif defined(USE_X11)
+  validator.reset(new viz::CompositorOverlayCandidateValidatorXShm(use_shm));
 #endif
 
   return validator;
@@ -491,10 +498,13 @@ void GpuProcessTransportFactory::Establi
         // surfaces as they are not following the correct mode.
         DisableGpuCompositing(compositor.get());
       }
+      bool use_shm = false;
+      std::unique_ptr<viz::SoftwareOutputDevice> output_device(CreateSoftwareOutputDevice(compositor->widget(), &use_shm));
       display_output_surface =
           std::make_unique<SoftwareBrowserCompositorOutputSurface>(
-              CreateSoftwareOutputDevice(compositor->widget()), vsync_callback,
-              compositor->task_runner());
+              std::move(output_device), vsync_callback,
+              compositor->task_runner(),
+              CreateOverlayCandidateValidator(compositor->widget(), use_shm));
     } else {
       DCHECK(context_provider);
       const auto& capabilities = context_provider->ContextCapabilities();
@@ -512,13 +522,13 @@ void GpuProcessTransportFactory::Establi
             compositor->widget(), context_provider, data->surface_handle,
             vsync_callback,
             CreateOverlayCandidateValidator(compositor->widget(),
-                                            disable_overlay_ca_layers),
+                                            disable_overlay_ca_layers, false),
             GetGpuMemoryBufferManager());
 #else
         auto gpu_output_surface =
             std::make_unique<GpuSurfacelessBrowserCompositorOutputSurface>(
                 context_provider, data->surface_handle, vsync_callback,
-                CreateOverlayCandidateValidator(compositor->widget()),
+                CreateOverlayCandidateValidator(compositor->widget(), false),
                 GL_TEXTURE_2D, GL_RGB,
                 display::DisplaySnapshot::PrimaryFormat(),
                 GetGpuMemoryBufferManager());
@@ -529,10 +539,10 @@ void GpuProcessTransportFactory::Establi
         std::unique_ptr<viz::CompositorOverlayCandidateValidator> validator;
 #if defined(OS_WIN)
         if (capabilities.dc_layers && capabilities.use_dc_overlays_for_video)
-          validator = CreateOverlayCandidateValidator(compositor->widget());
+          validator = CreateOverlayCandidateValidator(compositor->widget(), false);
 #elif !defined(OS_MACOSX)
         // Overlays are only supported on surfaceless output surfaces on Mac.
-        validator = CreateOverlayCandidateValidator(compositor->widget());
+        validator = CreateOverlayCandidateValidator(compositor->widget(), false);
 #endif
         auto gpu_output_surface =
             std::make_unique<GpuBrowserCompositorOutputSurface>(
Index: chromium-browser-65.0.3325.181/content/browser/compositor/gpu_process_transport_factory.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/compositor/gpu_process_transport_factory.h
+++ chromium-browser-65.0.3325.181/content/browser/compositor/gpu_process_transport_factory.h
@@ -117,7 +117,7 @@ class GpuProcessTransportFactory : publi
 
   PerCompositorData* CreatePerCompositorData(ui::Compositor* compositor);
   std::unique_ptr<viz::SoftwareOutputDevice> CreateSoftwareOutputDevice(
-      gfx::AcceleratedWidget widget);
+      gfx::AcceleratedWidget widget, bool * const puse_shm);
   void EstablishedGpuChannel(
       base::WeakPtr<ui::Compositor> compositor,
       bool use_gpu_compositing,
Index: chromium-browser-65.0.3325.181/content/browser/compositor/software_browser_compositor_output_surface.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/compositor/software_browser_compositor_output_surface.cc
+++ chromium-browser-65.0.3325.181/content/browser/compositor/software_browser_compositor_output_surface.cc
@@ -15,6 +15,7 @@
 #include "components/viz/service/display/output_surface_client.h"
 #include "components/viz/service/display/output_surface_frame.h"
 #include "components/viz/service/display/software_output_device.h"
+#include "components/viz/service/display_embedder/compositor_overlay_candidate_validator.h"
 #include "content/browser/renderer_host/render_widget_host_impl.h"
 #include "ui/gfx/vsync_provider.h"
 #include "ui/latency/latency_info.h"
@@ -30,6 +31,18 @@ SoftwareBrowserCompositorOutputSurface::
       task_runner_(std::move(task_runner)),
       weak_factory_(this) {}
 
+SoftwareBrowserCompositorOutputSurface::SoftwareBrowserCompositorOutputSurface(
+    std::unique_ptr<viz::SoftwareOutputDevice> software_device,
+    const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+    std::unique_ptr<viz::CompositorOverlayCandidateValidator>
+        overlay_candidate_validator)
+    : BrowserCompositorOutputSurface(std::move(software_device),
+                                     update_vsync_parameters_callback,
+                                     std::move(overlay_candidate_validator)),
+      task_runner_(std::move(task_runner)),
+      weak_factory_(this) {}
+
 SoftwareBrowserCompositorOutputSurface::
     ~SoftwareBrowserCompositorOutputSurface() {
 }
Index: chromium-browser-65.0.3325.181/content/browser/compositor/software_browser_compositor_output_surface.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/compositor/software_browser_compositor_output_surface.h
+++ chromium-browser-65.0.3325.181/content/browser/compositor/software_browser_compositor_output_surface.h
@@ -27,6 +27,13 @@ class CONTENT_EXPORT SoftwareBrowserComp
       const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
       scoped_refptr<base::SingleThreadTaskRunner> task_runner);
 
+  SoftwareBrowserCompositorOutputSurface(
+      std::unique_ptr<viz::SoftwareOutputDevice> software_device,
+      const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+      std::unique_ptr<viz::CompositorOverlayCandidateValidator>
+          overlay_candidate_validator);
+
   ~SoftwareBrowserCompositorOutputSurface() override;
 
   // OutputSurface implementation.
Index: chromium-browser-65.0.3325.181/content/browser/renderer_host/render_process_host_impl.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/renderer_host/render_process_host_impl.cc
+++ chromium-browser-65.0.3325.181/content/browser/renderer_host/render_process_host_impl.cc
@@ -2700,6 +2700,15 @@ void RenderProcessHostImpl::PropagateBro
     switches::kMus,
     switches::kMusHostingViz,
 #endif
+
+    switches::kMmalFrameBuffers, switches::kMmalZeroCopy,
+    switches::kMmalFrameCopy,    switches::kMmalSliceCopy,
+    switches::kMmalDecodeI420,   switches::kMmalDecodeOpaque,
+    switches::kMmalResizeIsp,    switches::kMmalResizeResizer,
+    switches::kMmalLowDelay,
+    switches::kMmalRedPixel,     switches::kMmalDecoders,
+    switches::kMmalDebugBench,   switches::kMmalDebugFps,
+    switches::kMmalDebugFixedSize,
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                  arraysize(kSwitchNames));
Index: chromium-browser-65.0.3325.181/content/browser/sandbox_ipc_linux.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/sandbox_ipc_linux.cc
+++ chromium-browser-65.0.3325.181/content/browser/sandbox_ipc_linux.cc
@@ -8,6 +8,7 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#include <sys/ioctl.h>
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
@@ -192,6 +193,8 @@ void SandboxIPCHandler::HandleRequestFro
   } else if (kind ==
              service_manager::SandboxLinux::METHOD_MATCH_WITH_FALLBACK) {
     HandleMatchWithFallback(fd, iter, fds);
+  } else if (kind == service_manager::SandboxLinux::METHOD_OPEN_DEV_VCHIQ) {
+    HandleOpenDevVchiq(fd, iter, fds);
   }
 }
 
@@ -410,6 +413,57 @@ void SandboxIPCHandler::HandleMatchWithF
       PLOG(ERROR) << "close";
   }
 }
+
+#define IOCTL_MBOX_PROPERTY _IOWR(100, 0, char *)
+#define VCIO_PATH "/dev/vcio"
+
+static uint32_t pi_firmware_date()
+{
+  int vcio_fd = IGNORE_EINTR(open(VCIO_PATH, 0));
+
+  if (vcio_fd == -1) {
+    PLOG(ERROR) << "Failed to open " VCIO_PATH;
+    return 0;
+  }
+
+  uint32_t req_buf[256] = {
+    (4+3)*4, 0,  // 4 args, + 3 overhead
+    1, 4, 4, 0,  // args
+  };
+
+  int err = IGNORE_EINTR(ioctl(vcio_fd, IOCTL_MBOX_PROPERTY, req_buf));
+  uint32_t rv = req_buf[5];
+
+  if (err < 0) {
+    PLOG(ERROR) << VCIO_PATH ": ioctl";
+    rv = 0;
+  }
+
+  if (IGNORE_EINTR(close(vcio_fd)) < 0)
+    PLOG(ERROR) << VCIO_PATH ": close";
+  return rv;
+}
+
+void SandboxIPCHandler::HandleOpenDevVchiq(
+    int fd,
+    base::PickleIterator iter,
+    const std::vector<base::ScopedFD>& fds)
+{
+  const int vchiq_fd = IGNORE_EINTR(open("/dev/vchiq", O_RDWR));
+
+  if (vchiq_fd == -1) {
+    PLOG(ERROR) << "Failed to open vchiq";
+  }
+
+  base::Pickle reply;
+  reply.WriteUInt32(pi_firmware_date());
+  SendRendererReply(fds, reply, vchiq_fd);
+
+  if (vchiq_fd >= 0) {
+    if (IGNORE_EINTR(close(vchiq_fd)) < 0)
+      PLOG(ERROR) << "close";
+  }
+}
 
 void SandboxIPCHandler::SendRendererReply(
     const std::vector<base::ScopedFD>& fds,
Index: chromium-browser-65.0.3325.181/content/browser/sandbox_ipc_linux.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/content/browser/sandbox_ipc_linux.h
+++ chromium-browser-65.0.3325.181/content/browser/sandbox_ipc_linux.h
@@ -74,6 +74,10 @@ class SandboxIPCHandler : public base::D
                                base::PickleIterator iter,
                                const std::vector<base::ScopedFD>& fds);
 
+  void HandleOpenDevVchiq(int fd,
+                               base::PickleIterator iter,
+                               const std::vector<base::ScopedFD>& fds);
+
   void SendRendererReply(const std::vector<base::ScopedFD>& fds,
                          const base::Pickle& reply,
                          int reply_fd);
Index: chromium-browser-65.0.3325.181/media/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/BUILD.gn
+++ chromium-browser-65.0.3325.181/media/BUILD.gn
@@ -83,6 +83,7 @@ config("subcomponent_config") {
 
 component("media") {
   libs = []
+  ldflags = []
 
   deps = [
     "//base",
@@ -115,6 +116,16 @@ component("media") {
   if (is_mac || is_ios) {
     public_deps += [ "//media/base/mac" ]
   }
+
+  if (current_cpu == "arm" && is_component_build) {
+    # Add pi link stuff
+    # * is there a better place?
+    ldflags += [
+     "-L$sysroot/opt/vc/lib",
+     "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+     "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+    ]
+  }
 }
 
 # Note: This can't be a static_library since it does not have any sources.
Index: chromium-browser-65.0.3325.181/media/audio/alsa/alsa_output.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/audio/alsa/alsa_output.cc
+++ chromium-browser-65.0.3325.181/media/audio/alsa/alsa_output.cc
@@ -138,7 +138,10 @@ const char AlsaPcmOutputStream::kPlugPre
 
 // We use 40ms as our minimum required latency. If it is needed, we may be able
 // to get it down to 20ms.
-const uint32_t AlsaPcmOutputStream::kMinLatencyMicros = 40 * 1000;
+// ** (Pi) When life gets hard we don't seem to cycle fast enough for 40ms to be
+// long enough (actually it is approx half that as we put off reload until
+// half full)
+const uint32_t AlsaPcmOutputStream::kMinLatencyMicros = 200 * 1000;
 
 AlsaPcmOutputStream::AlsaPcmOutputStream(const std::string& device_name,
                                          const AudioParameters& params,
Index: chromium-browser-65.0.3325.181/media/base/media_switches.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/base/media_switches.cc
+++ chromium-browser-65.0.3325.181/media/base/media_switches.cc
@@ -173,6 +173,22 @@ const char kUserGestureRequiredForCrossO
 
 }  // namespace autoplay
 
+const char kMmalFrameBuffers[]              = "mmal-frame-buffers";
+const char kMmalZeroCopy[]                  = "mmal-zero-copy";
+const char kMmalFrameCopy[]                 = "mmal-frame-copy";
+const char kMmalSliceCopy[]                 = "mmal-slice-copy";
+const char kMmalDecodeI420[]                = "mmal-decode-i420";
+const char kMmalDecodeOpaque[]              = "mmal-decode-opaque";
+const char kMmalResizeIsp[]                 = "mmal-resize-isp";
+const char kMmalResizeResizer[]             = "mmal-resize-resizer";
+const char kMmalLowDelay[]                  = "mmal-low-delay";
+const char kMmalRedPixel[]                  = "mmal-red-pixel";
+const char kMmalDecoders[]                  = "mmal-decoders";
+
+const char kMmalDebugBench[]                = "mmal-debug-bench";
+const char kMmalDebugFps[]                  = "mmal-debug-fps";
+const char kMmalDebugFixedSize[]            = "mmal-debug-fixed-size";
+
 }  // namespace switches
 
 namespace media {
Index: chromium-browser-65.0.3325.181/media/base/media_switches.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/base/media_switches.h
+++ chromium-browser-65.0.3325.181/media/base/media_switches.h
@@ -97,6 +97,22 @@ MEDIA_EXPORT extern const char kUserGest
 
 }  // namespace autoplay
 
+MEDIA_EXPORT extern const char kMmalFrameBuffers[];
+MEDIA_EXPORT extern const char kMmalZeroCopy[];
+MEDIA_EXPORT extern const char kMmalFrameCopy[];
+MEDIA_EXPORT extern const char kMmalSliceCopy[];
+MEDIA_EXPORT extern const char kMmalDecodeI420[];
+MEDIA_EXPORT extern const char kMmalDecodeOpaque[];
+MEDIA_EXPORT extern const char kMmalResizeIsp[];
+MEDIA_EXPORT extern const char kMmalResizeResizer[];
+MEDIA_EXPORT extern const char kMmalLowDelay[];
+MEDIA_EXPORT extern const char kMmalRedPixel[];
+MEDIA_EXPORT extern const char kMmalDecoders[];
+
+MEDIA_EXPORT extern const char kMmalDebugBench[];
+MEDIA_EXPORT extern const char kMmalDebugFps[];
+MEDIA_EXPORT extern const char kMmalDebugFixedSize[];
+
 }  // namespace switches
 
 namespace media {
Index: chromium-browser-65.0.3325.181/media/base/video_frame.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/base/video_frame.cc
+++ chromium-browser-65.0.3325.181/media/base/video_frame.cc
@@ -111,6 +111,7 @@ bool RequiresEvenSizeAllocation(VideoPix
     case PIXEL_FORMAT_RGB24:
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_Y16:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return false;
     case PIXEL_FORMAT_NV12:
     case PIXEL_FORMAT_NV21:
@@ -166,7 +167,7 @@ bool VideoFrame::IsValidConfig(VideoPixe
     return true;
 
   // Make sure new formats are properly accounted for in the method.
-  static_assert(PIXEL_FORMAT_MAX == 26,
+  static_assert(PIXEL_FORMAT_MAX == 27,
                 "Added pixel format, please review IsValidConfig()");
 
   if (format == PIXEL_FORMAT_UNKNOWN) {
@@ -518,6 +519,7 @@ size_t VideoFrame::NumPlanes(VideoPixelF
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_MJPEG:
     case PIXEL_FORMAT_Y16:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return 1;
     case PIXEL_FORMAT_NV12:
     case PIXEL_FORMAT_NV21:
@@ -846,6 +848,7 @@ size_t VideoFrame::BitDepth() const {
     case media::PIXEL_FORMAT_RGB32:
     case media::PIXEL_FORMAT_MJPEG:
     case media::PIXEL_FORMAT_MT21:
+    case media::PIXEL_FORMAT_MMAL_BUFFER:
       return 8;
     case media::PIXEL_FORMAT_YUV420P9:
     case media::PIXEL_FORMAT_YUV422P9:
@@ -1122,6 +1125,7 @@ gfx::Size VideoFrame::SampleSize(VideoPi
         case PIXEL_FORMAT_RGB24:
         case PIXEL_FORMAT_RGB32:
         case PIXEL_FORMAT_MJPEG:
+        case PIXEL_FORMAT_MMAL_BUFFER:
           break;
       }
   }
@@ -1136,6 +1140,7 @@ int VideoFrame::BytesPerElement(VideoPix
     case PIXEL_FORMAT_ARGB:
     case PIXEL_FORMAT_XRGB:
     case PIXEL_FORMAT_RGB32:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return 4;
     case PIXEL_FORMAT_RGB24:
       return 3;
Index: chromium-browser-65.0.3325.181/media/base/video_frame.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/base/video_frame.h
+++ chromium-browser-65.0.3325.181/media/base/video_frame.h
@@ -35,6 +35,8 @@ namespace media {
 
 class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
  public:
+  typedef base::Callback<void(const gfx::Size&)> MmalResizeCB;
+
   enum {
     kFrameSizeAlignment = 16,
     kFrameSizePadding = 16,
@@ -304,6 +306,9 @@ class MEDIA_EXPORT VideoFrame : public b
   gfx::ColorSpace ColorSpace() const;
   void set_color_space(const gfx::ColorSpace& color_space);
 
+  // Mmal resize kludge info
+  MmalResizeCB mmal_resize_cb_;
+
   VideoPixelFormat format() const { return format_; }
   StorageType storage_type() const { return storage_type_; }
 
Index: chromium-browser-65.0.3325.181/media/base/video_types.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/base/video_types.cc
+++ chromium-browser-65.0.3325.181/media/base/video_types.cc
@@ -62,6 +62,8 @@ std::string VideoPixelFormatToString(Vid
       return "PIXEL_FORMAT_YUV444P12";
     case PIXEL_FORMAT_Y16:
       return "PIXEL_FORMAT_Y16";
+    case PIXEL_FORMAT_MMAL_BUFFER:
+      return "PIXEL_FORMAT_MMAL_BUFFER";
   }
   NOTREACHED() << "Invalid VideoPixelFormat provided: " << format;
   return "";
@@ -86,6 +88,7 @@ bool IsYuvPlanar(VideoPixelFormat format
     case PIXEL_FORMAT_YUV420P12:
     case PIXEL_FORMAT_YUV422P12:
     case PIXEL_FORMAT_YUV444P12:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return true;
 
     case PIXEL_FORMAT_UNKNOWN:
@@ -127,6 +130,7 @@ bool IsOpaque(VideoPixelFormat format) {
     case PIXEL_FORMAT_YUV422P12:
     case PIXEL_FORMAT_YUV444P12:
     case PIXEL_FORMAT_Y16:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return true;
     case PIXEL_FORMAT_I420A:
     case PIXEL_FORMAT_ARGB:
Index: chromium-browser-65.0.3325.181/media/base/video_types.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/base/video_types.h
+++ chromium-browser-65.0.3325.181/media/base/video_types.h
@@ -66,9 +66,11 @@ enum VideoPixelFormat {
   /* PIXEL_FORMAT_Y8 = 25, Deprecated */
   PIXEL_FORMAT_Y16 = 26,  // single 16bpp plane.
 
+  PIXEL_FORMAT_MMAL_BUFFER = 27,
+
   // Please update UMA histogram enumeration when adding new formats here.
   PIXEL_FORMAT_MAX =
-      PIXEL_FORMAT_Y16,  // Must always be equal to largest entry logged.
+      PIXEL_FORMAT_MMAL_BUFFER,  // Must always be equal to largest entry logged.
 };
 
 // Color space or color range used for the pixels.
Index: chromium-browser-65.0.3325.181/media/filters/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/filters/BUILD.gn
+++ chromium-browser-65.0.3325.181/media/filters/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("//media/media_options.gni")
 import("//third_party/libaom/options.gni")
+import("//build/config/sysroot.gni")
 
 source_set("filters") {
   # Do not expand the visibility here without double-checking with OWNERS, this
@@ -108,6 +109,7 @@ source_set("filters") {
   ]
 
   libs = []
+  include_dirs = []
 
   if (proprietary_codecs) {
     sources += [
@@ -209,6 +211,19 @@ source_set("filters") {
       "h264_bitstream_buffer.h",
     ]
   }
+
+  # Really should have some sort of global enable_mmal switch
+  if (current_cpu == "arm" && is_linux) {
+    sources += [
+      "mmal_video_decoder.cc",
+      "mmal_video_decoder.h",
+    ]
+    include_dirs += [
+      "$target_sysroot/opt/vc/include",
+      "$target_sysroot/opt/vc/include/interface/vcos/pthreads",
+      "$target_sysroot/opt/vc/include/interface/vmcs_host/linux",
+    ]
+  }
 }
 
 source_set("perftests") {
Index: chromium-browser-65.0.3325.181/media/filters/mmal_video_decoder.cc
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/media/filters/mmal_video_decoder.cc
@@ -0,0 +1,3907 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/filters/mmal_video_decoder.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <algorithm>
+#include <string>
+
+//#include "base/base_switches.h"
+#include "base/bind.h"
+#include "base/callback_helpers.h"
+#include "base/command_line.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/pickle.h"
+#include "base/memory/ptr_util.h"
+#include "base/posix/unix_domain_socket.h"
+//#include "content/public/common/content_switches.h"
+#include "media/base/bind_to_current_loop.h"
+#include "media/base/decoder_buffer.h"
+#include "media/base/limits.h"
+#include "media/base/media_switches.h"
+#include "media/base/timestamp_constants.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_util.h"
+#include "services/service_manager/sandbox/linux/sandbox_linux.h"
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/mmal_buffer.h>
+#include <interface/mmal/mmal_parameters_video.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_connection.h>
+#include <interface/mmal/core/mmal_buffer_private.h>  // *** debug
+#include <interface/mmal/vc/mmal_vc_api.h>
+extern "C" {
+#include <interface/vmcs_host/vc_vchi_gencmd.h>
+}
+
+#include <iomanip>
+
+// Debug & test defines
+#define OPT_FRAME_COPY_STASHED 1
+#define TRACE_COMPONENT_CREATION 0
+#define TRACE_TRAMPOLINE 0
+#define TRACE_FRAME_STASH_NEW  0  // Traces memory allocated by FrameStash
+
+// Missing defn
+#define MMAL_COMPONENT_DEFAULT_RESIZER "vc.ril.resize"
+#define MMAL_COMPONENT_ISP_RESIZER "vc.ril.isp"
+
+#define MMAL_SLICE_HEIGHT 16
+#define MMAL_ALIGN_W      32
+#define MMAL_ALIGN_H      16
+
+#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(1920, MMAL_ALIGN_W)
+#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1088, MMAL_ALIGN_H)
+//#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(2048, MMAL_ALIGN_W)
+//#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1280, MMAL_ALIGN_H)
+
+#define FRAME_COPY_DEFAULT_BUFFERS      2
+#define SLICE_COPY_DEFAULT_BUFFERS      16
+#define ZERO_COPY_DEFAULT_BUFFERS       6
+
+#define MAX_COPY_FRAMES_IN_FLIGHT       8
+
+namespace media {
+
+enum FrameCopyMode {
+  unset,
+  SLICE,
+  FRAME,
+  ZERO
+};
+
+// Not strictly a decoder count - this is inced @ initialisation
+static volatile base::subtle::Atomic32 decoder_count = 0;
+
+// Supported decoder bitmap (indexed by VideoCodec)
+static unsigned int supported_video_codecs = 0;
+
+// Task runner - current SingleThread - probably no reason
+// why it shouldn't be Sequenced so typedef for ease of changing
+typedef scoped_refptr<base::SingleThreadTaskRunner> MmalTaskRunner;
+
+
+// Some classes that we have fwd refs to
+class MmalConnectedPort;
+class MmalComponent;
+
+// ---------------------------------------------------------------------------
+//
+// Dup these from sandbox code in content as we end up with circular refs if I
+// try and use them directly :-(
+
+#if 0
+#include "content/child/child_process_sandbox_support_impl_linux.h"
+#include "content/public/common/common_sandbox_support_linux.h"
+
+#define ipc_shm content::MakeSharedMemorySegmentViaIPC
+#define ipc_fd content::GetSandboxFD
+#else
+#include "content/public/common/content_descriptors.h"
+
+static int ipc_fd() {
+  return kSandboxIPCChannel + base::GlobalDescriptors::kBaseDescriptor;
+}
+
+static int ipc_shm(size_t length, bool executable) {
+  base::Pickle request;
+  request.WriteInt(
+      service_manager::SandboxLinux::METHOD_MAKE_SHARED_MEMORY_SEGMENT);
+  request.WriteUInt32(length);
+  request.WriteBool(executable);
+  uint8_t reply_buf[10];
+  int result_fd;
+  ssize_t result = base::UnixDomainSocket::SendRecvMsg(
+      ipc_fd(), reply_buf, sizeof(reply_buf), &result_fd, request);
+  if (result == -1)
+    return -1;
+  return result_fd;
+}
+
+#endif
+
+// ----------------------------------------------------------------------------
+//
+// Misc helper fns
+
+static inline size_t RoundUp(size_t value, size_t alignment) {
+  return ((value + (alignment - 1)) & ~(alignment - 1));
+}
+
+// Zap & release buffer
+static void buffer_release(MMAL_BUFFER_HEADER_T * const buffer)
+{
+  mmal_buffer_header_reset(buffer);
+  mmal_buffer_header_release(buffer);
+}
+
+// Calculate pixel aspect ratio
+static gfx::Size par_from_sizes(const gfx::Size& coded, const gfx::Size& natural)
+{
+  uint32_t a = coded.width() * natural.height();
+  uint32_t b = coded.height() * natural.width();
+
+  // Deal with the trivial case
+
+  if (a == b) {
+    return gfx::Size(1, 1);
+  }
+
+  // reduce - probably not needed but it might well save overflow
+  // or precision reduction later in the code
+  // We only expect to do this at init time so inefficiency isn't important
+
+  static const uint32_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19};
+  for (int i = 0; i != sizeof(primes)/sizeof(primes[0]); ++i) {
+    const uint32_t p = primes[i];
+    while (a % p == 0 && b % p == 0) {
+      a /= p;
+      b /= p;
+    }
+  }
+
+  return gfx::Size(b, a);
+}
+
+// Convert a time_t to a printable string
+// * Surely there is a std C++ fn for this?
+static std::string strgmtimet(const time_t tt)
+{
+  char tbuf[32];
+  struct tm tm;
+  gmtime_r(&tt, &tm);
+  tbuf[sizeof(tbuf)-1] = 0;
+  snprintf(tbuf, sizeof(tbuf) - 1, "%04d-%02d-%02d %02d:%02d:%02d UTC",
+      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+      tm.tm_hour, tm.tm_min, tm.tm_sec);
+  return std::string(tbuf);
+}
+
+
+static VideoCodec fourcc_to_video_codec(const MMAL_FOURCC_T x)
+{
+  switch (x) {
+    case MMAL_ENCODING_H264:
+      return VideoCodec::kCodecH264;
+    case MMAL_ENCODING_WVC1:
+      return VideoCodec::kCodecVC1;
+    case MMAL_ENCODING_MP1V:
+    case MMAL_ENCODING_MP2V:
+      return VideoCodec::kCodecMPEG2;
+    case MMAL_ENCODING_MP4V:
+      return VideoCodec::kCodecMPEG4;
+    case MMAL_ENCODING_THEORA:
+      return VideoCodec::kCodecTheora;
+    case MMAL_ENCODING_VP8:
+      return VideoCodec::kCodecVP8;
+    // Missing FOURCC for
+    // kCodecVP9,
+    // kCodecHEVC,
+    default:
+      break;
+  }
+  return VideoCodec::kUnknownVideoCodec;
+}
+
+static MMAL_FOURCC_T video_codec_to_fourcc(const VideoCodec x)
+{
+  switch (x) {
+    case VideoCodec::kCodecH264:
+      return MMAL_ENCODING_H264;
+    case VideoCodec::kCodecVC1:
+      return MMAL_ENCODING_WVC1;
+    case VideoCodec::kCodecMPEG2:
+      return MMAL_ENCODING_MP2V;
+    case VideoCodec::kCodecMPEG4:
+      return MMAL_ENCODING_MP4V;
+    case VideoCodec::kCodecTheora:
+      return MMAL_ENCODING_THEORA;
+    case VideoCodec::kCodecVP8:
+      return MMAL_ENCODING_VP8;
+    // Missing FOURCC for
+    // kCodecVP9,
+    // kCodecHEVC,
+    default:
+      break;
+  }
+  return MMAL_ENCODING_UNKNOWN;
+}
+
+static std::string fourcc_string(const MMAL_FOURCC_T fourcc)
+{
+  char buf[10];
+  mmal_4cc_to_string(buf, sizeof(buf), fourcc);
+  return std::string(buf);
+}
+
+static const char * frame_copy_mode_str(const FrameCopyMode mode)
+{
+  switch (mode) {
+    case FrameCopyMode::unset:
+      return "unset";
+    case FrameCopyMode::SLICE:
+      return "SLICE";
+    case FrameCopyMode::FRAME:
+      return "FRAME";
+    case FrameCopyMode::ZERO:
+      return "ZERO";
+    default:
+      break;
+  }
+  return "???";
+}
+
+//-----------------------------------------------------------------------------
+
+
+class MmalVideoDecoder::Options
+{
+  const bool single_process_;
+  const bool zero_copy_;
+  const bool frame_copy_;
+  const bool slice_copy_;
+  const bool red_pixel_;
+  const bool decode_opaque_;
+  const bool decode_i420_;
+  const bool resize_isp_;
+  const bool resize_resizer_;
+  const bool low_delay_;
+  const unsigned int frame_buffers_;
+  const unsigned int decoders_;
+
+  const bool debug_bench_;
+  const bool debug_fps_;
+  const gfx::Size debug_fixed_size_;
+
+  size_t gpu_mem_;
+  uint32_t firmware_date_;
+
+  static unsigned int cl_uint(const base::CommandLine& cmd_line, const char name[], const unsigned int def_val = 0)
+  {
+      unsigned int val;
+      return base::StringToUint(cmd_line.GetSwitchValueNative(name), &val) ? val : def_val;
+  }
+
+  static bool cl_flag(const base::CommandLine& cmd_line, const char name[])
+  {
+      return cmd_line.HasSwitch(name);
+  }
+
+  static gfx::Size cl_size(const base::CommandLine& cmd_line, const char name[])
+  {
+      const char * const cl(cmd_line.GetSwitchValueNative(name).c_str());
+      char * eoi = NULL;
+      const unsigned long w = strtoul(cl, &eoi, 10);
+      if (*eoi != 'x' && *eoi != 'X') {
+        return gfx::Size();
+      }
+      const unsigned long h = strtoul(eoi + 1, &eoi, 10);
+      if (*eoi != '\0') {
+        return gfx::Size();
+      }
+      return gfx::Size(w, h);
+  }
+
+  struct FirmwareDates {
+    static constexpr uint32_t HasOpaque = 1477958400;  // 2016-11-01
+    static constexpr uint32_t HasIsp = 1477958400;  // 2016-11-01
+  };
+
+  Options(const base::CommandLine& cmd_line) :
+    single_process_(cl_flag(cmd_line, "single-process" /*switches::kSingleProcess*/)),  // Just too hard to get libs right
+    zero_copy_(cl_flag(cmd_line, switches::kMmalZeroCopy)),
+    frame_copy_(cl_flag(cmd_line, switches::kMmalFrameCopy)),
+    slice_copy_(cl_flag(cmd_line, switches::kMmalSliceCopy)),
+    red_pixel_(cl_flag(cmd_line, switches::kMmalRedPixel)),
+    decode_opaque_(cl_flag(cmd_line, switches::kMmalDecodeOpaque)),
+    decode_i420_(cl_flag(cmd_line, switches::kMmalDecodeI420)),
+    resize_isp_(cl_flag(cmd_line, switches::kMmalResizeIsp)),
+    resize_resizer_(cl_flag(cmd_line, switches::kMmalResizeResizer)),
+    low_delay_(cl_flag(cmd_line, switches::kMmalLowDelay)),
+    frame_buffers_(cl_uint(cmd_line, switches::kMmalFrameBuffers)),
+    decoders_(cl_uint(cmd_line, switches::kMmalDecoders, 1)),
+    debug_bench_(cl_flag(cmd_line, switches::kMmalDebugBench)),
+    debug_fps_(cl_flag(cmd_line, switches::kMmalDebugFps)),
+    debug_fixed_size_(cl_size(cmd_line, switches::kMmalDebugFixedSize)),
+    gpu_mem_(0),
+    firmware_date_(0)
+  {
+  }
+
+  bool opaque_good() const
+  {
+    return firmware_date_ >= FirmwareDates::HasOpaque;
+  }
+
+  bool isp_resize_good() const
+  {
+    return firmware_date_ >= FirmwareDates::HasIsp &&
+      gpu_mem_ >= (76 << 20);  // Take 76M as threshold for ISP use
+  }
+
+public:
+  static std::unique_ptr<Options> Create(const base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess())
+  {
+    return std::unique_ptr<Options>(new Options(cmd_line));
+  }
+
+  // Default encoding now opaque
+  MMAL_FOURCC_T decoder_out_encoding() const
+  {
+    return  decode_i420_ || !(decode_opaque_ || opaque_good()) ?
+      MMAL_ENCODING_I420 :
+      MMAL_ENCODING_OPAQUE;
+  }
+
+  const char * resizer_component_name() const
+  {
+    return resize_resizer_ || !(resize_isp_ || isp_resize_good()) ?
+      MMAL_COMPONENT_DEFAULT_RESIZER :
+      MMAL_COMPONENT_ISP_RESIZER;
+  }
+
+  FrameCopyMode frame_copy_mode(const bool has_slice_resize) const
+  {
+    return zero_copy_ ? FrameCopyMode::ZERO :
+      frame_copy_ ? FrameCopyMode::FRAME :
+      slice_copy_ ? FrameCopyMode::SLICE :
+      has_slice_resize && !isp_resize_good() ? FrameCopyMode::SLICE : FrameCopyMode::FRAME;
+  }
+
+  unsigned int frame_buffers(const FrameCopyMode copy_mode) const
+  {
+    return frame_buffers_ != 0 ? frame_buffers_ :
+      copy_mode == FrameCopyMode::ZERO ? ZERO_COPY_DEFAULT_BUFFERS :
+      copy_mode == FrameCopyMode::SLICE ? SLICE_COPY_DEFAULT_BUFFERS : FRAME_COPY_DEFAULT_BUFFERS;
+  }
+
+  bool single_process() const
+  {
+    return single_process_;
+  }
+
+  unsigned int max_decoders() const
+  {
+    return decoders_;
+  }
+
+  bool red_pixel() const
+  {
+    return red_pixel_;
+  }
+
+  bool low_delay(const bool low_delay_req = false) const
+  {
+    return low_delay_ || low_delay_req;
+  }
+
+  bool debug_bench() const
+  {
+    return debug_bench_;
+  }
+
+  bool debug_fps() const
+  {
+    return debug_bench_ || debug_fps_;
+  }
+
+  bool debug_fixed_size_set() const
+  {
+    return debug_fixed_size_.width() > 0 && debug_fixed_size_.height()  > 0;
+  }
+
+  gfx::Size debug_fixed_size() const
+  {
+    return debug_fixed_size_;
+  }
+
+  void set_gpu_mem(const size_t size)
+  {
+    gpu_mem_ = size;
+  }
+
+  void set_firmware_date(const uint32_t date)
+  {
+    firmware_date_ = date;
+  }
+
+  std::string ToString() const
+  {
+    std::ostringstream s;
+    s << "mmal frame_buffers=" << frame_buffers_ <<
+       ", mmal_X_copy (z/f/s)=" << zero_copy_  << "/"  << frame_copy_ << "/" << slice_copy_ <<
+       ", mmal_low_delay=" << low_delay_ <<
+       ", mmal_decode_i420/opaque=" << decode_i420_ << "/" << decode_opaque_ <<
+       ", mmal_resize_isp=" << resize_isp_ <<
+       ", mmal_decoders=" << decoders_ <<
+       ", mmal_debug_bench=" << debug_bench_ <<
+       ", mmal_debug_fps=" << debug_fps_ <<
+       ", mmal_debug_fixed_size=" << debug_fixed_size_.ToString() <<
+       ", gpu_mem=" << gpu_mem_ <<
+       ", firmware_date=" << strgmtimet(firmware_date_);
+    return s.str();
+  }
+
+  std::string OptString() const
+  {
+    std::ostringstream s;
+    s << "isp_resize_good=" << isp_resize_good() <<
+      ", frame_copy_mode=" << frame_copy_mode_str(frame_copy_mode(true)) <<
+      ", resizer_component=" << resizer_component_name() <<
+      ", encoding=" << fourcc_string(decoder_out_encoding());
+    return s.str();
+  }
+};
+
+
+//-----------------------------------------------------------------------------
+
+
+#if TRACE_FRAME_STASH_NEW
+volatile base::subtle::Atomic32 total_stash_alloc = 0;
+#endif
+
+
+#if 1
+class FrameDesc
+{
+  uint32_t size_;
+  std::unique_ptr<base::SharedMemory> shm_;
+  gpu::Mailbox id_;
+  base::Closure on_kill_cb_;
+
+public:
+  FrameDesc(const size_t size) :
+    size_((uint32_t)size)
+  {
+#if TRACE_FRAME_STASH_NEW
+    const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, (base::subtle::Atomic32)size);
+    LOG(ERROR) << "New frame: size=" << size << ", total=" << talloc;
+#endif
+
+    int fd = ipc_shm(size, false);
+    if (fd == -1) {
+      LOG(ERROR) << "shm open fail";
+    }
+    else
+    {
+//      LOG(ERROR) << "shm open succeed";
+      shm_ = std::unique_ptr<base::SharedMemory>(new base::SharedMemory(
+        base::SharedMemoryHandle::ImportHandle(fd, size), false));
+
+      if (!shm_->Map(size))
+      {
+        LOG(ERROR) << "### Shm creation failed";
+        return;
+      }
+    }
+  }
+
+  ~FrameDesc()
+  {
+//    LOG(ERROR) << " destroy frame desc fd=" << (shm_ == nullptr ? -99 : shm_->handle().fd);
+    if (!on_kill_cb_.is_null()) {
+      on_kill_cb_.Run();
+    }
+#if TRACE_FRAME_STASH_NEW
+    if (shm_->memory() != nullptr) {
+      const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, -(base::subtle::Atomic32)size_);
+      LOG(ERROR) << "Delete frame: size=" << size_ << ", total=" << talloc;
+    }
+#endif
+  }
+
+  uint8_t * frame() const
+  {
+    return (uint8_t *)shm_->memory();
+  }
+
+  size_t size() const
+  {
+    return size_;
+  }
+
+  base::SharedMemoryHandle shared_memory() const
+  {
+    return shm_->handle();
+  }
+
+  void set_id_and_kill_cb(const gpu::Mailbox& id, const base::Closure& kill_cb)
+  {
+    if (id.IsZero()) {
+      return;
+    }
+    if (!id_.IsZero()) {
+      if (id != id_) {
+        LOG(ERROR) << "FrameDesc::" << __func__ << " ids don't match: " << MmalVideoFrame::hashid(id) << " -> " << MmalVideoFrame::hashid(id_);
+      }
+      return;
+    }
+    id_ = id;
+//    LOG(ERROR) << "FrameDesc::" << __func__ << " id=" << MmalVideoFrame::hashid(id);
+    if (!kill_cb.is_null()) {
+      on_kill_cb_ = kill_cb;
+    }
+  }
+
+  const gpu::Mailbox& get_id() const
+  {
+    return id_;
+  }
+};
+#else
+
+// Shared memory frames allocated by our parent process
+// Surprisingly the sandbox does let us allocate then here but this process
+// tends to be killed violently and that in turn leaks shmids as they need
+// to exist at least until mapped by X
+class FrameDesc
+{
+  uint32_t size_;
+  std::unique_ptr<base::SysvSharedMemory> shm_;
+  gpu::Mailbox id_;
+  base::Closure on_kill_cb_;
+
+public:
+  FrameDesc(const size_t size) :
+    size_((uint32_t)size)
+  {
+#if TRACE_FRAME_STASH_NEW
+    const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, (base::subtle::Atomic32)size);
+    LOG(ERROR) << "New frame: size=" << size << ", total=" << talloc;
+#endif
+
+    shm_ = std::unique_ptr<base::SysvSharedMemory>(new base::SysvSharedMemory(shm_get_id(size_), false));
+
+    if (!shm_->Map())
+    {
+      LOG(ERROR) << "Failed to create shared memory segment";
+    }
+  }
+
+  ~FrameDesc()
+  {
+//    LOG(ERROR) << " destroy frame desc fd=" << (shm_ == nullptr ? -99 : shm_->handle().fd);
+    if (!on_kill_cb_.is_null()) {
+      on_kill_cb_.Run();
+    }
+#if TRACE_FRAME_STASH_NEW
+    if (mapaddr_ != nullptr) {
+      const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, -(base::subtle::Atomic32)size_);
+      LOG(ERROR) << "Delete frame: size=" << size_ << ", total=" << talloc;
+    }
+#endif
+    if (shm_ != nullptr) {
+      shm_rm_id(shm_->shmid());
+    }
+  }
+
+  uint8_t * frame() const
+  {
+    return (uint8_t *)shm_->memory();
+  }
+
+  size_t size() const
+  {
+    return size_;
+  }
+
+  int shmid() const
+  {
+    return shm_->shmid();
+  }
+
+  void set_id_and_kill_cb(const gpu::Mailbox& id, const base::Closure& kill_cb)
+  {
+    if (id.IsZero()) {
+      return;
+    }
+    if (!id_.IsZero()) {
+      if (id != id_) {
+        LOG(ERROR) << "FrameDesc::" << __func__ << " ids don't match: " << MmalVideoFrame::hashid(id) << " -> " << MmalVideoFrame::hashid(id_);
+      }
+      return;
+    }
+    id_ = id;
+//    LOG(ERROR) << "FrameDesc::" << __func__ << " id=" << MmalVideoFrame::hashid(id);
+    if (!kill_cb.is_null()) {
+      on_kill_cb_ = kill_cb;
+    }
+  }
+
+  const gpu::Mailbox& get_id() const
+  {
+    return id_;
+  }
+};
+#endif
+
+// Simple class to stash frames
+// Thread unsafe - use external locks
+class FrameStash
+{
+  size_t size_;
+  std::stack<FrameDesc *> frames_;
+
+  FrameDesc * frame_pop()
+  {
+    FrameDesc * const frame = frames_.top();
+    frames_.pop();
+    return frame;
+  }
+
+  void empty_frames()
+  {
+    while (!frames_.empty()) {
+      delete frame_pop();
+    }
+  }
+
+public:
+  FrameStash()
+  {
+  }
+  virtual ~FrameStash()
+  {
+    empty_frames();
+  }
+
+  void free_frame(FrameDesc * const frame)
+  {
+    if (frame->size() != size_) {
+      delete frame;
+    }
+    else {
+      frames_.push(frame);
+    }
+  }
+
+  FrameDesc * alloc_frame(const size_t size)
+  {
+    if (size != size_) {
+      empty_frames();
+    }
+    size_ = size;
+
+    FrameDesc * const frame = (size == 0) ? nullptr :
+      frames_.empty() ? new FrameDesc(size) : frame_pop();
+
+    return frame;
+  }
+};
+
+//-----------------------------------------------------------------------------
+
+// Trampoline class
+// This allows us to attach callbacks from VideoFrames to our
+// component / port without it locking down the component.
+// If the component is dead by the time the callback arrives then it is simply
+// dropped on the floor
+//
+// * Extended well past original intention - rather more than just
+//   a trampoline now... Should be renamed
+
+// A number of functions in this class (in particular "kill") look like they
+// might cause suicide which would be bad as the AutoLock would be removed
+// after it was destroyed. This is prevented by the fact that this class should
+// only be accessed though scoped_refptrs so the calling fn should have a ref
+// on us for at least the duration of the call.
+
+class MmalTrampoline : public base::RefCountedThreadSafe<MmalTrampoline>
+{
+  typedef base::Callback<void(const int)> MmalCopiedFramedDestructionCB;
+#if TRACE_TRAMPOLINE
+  // These two are only used for debug
+  static int seq_count_; // Seq number counter
+  const int seq_;  // Debugging sequence number
+#endif
+
+  base::Lock lock_;
+  int in_flight_;
+  bool low_traced_;
+  const int max_in_flight_;
+  VideoFrame::MmalResizeCB resize_cb_;
+  MmalCopiedFramedDestructionCB destruction_cb_;
+  FrameStash frame_stash_;
+
+  void resize_trampoline(const gfx::Size& size)
+  {
+//    LOG(ERROR) << __func__ ;
+    base::AutoLock lock(lock_);
+    if (!resize_cb_.is_null())
+      resize_cb_.Run(size);
+  }
+
+  friend base::RefCountedThreadSafe<MmalTrampoline>;
+  virtual ~MmalTrampoline()
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "@@@ " << __func__ << "[" << seq_ << "]";
+#endif
+  }
+public:
+  MmalTrampoline(
+      const int max_in_flight,
+      const VideoFrame::MmalResizeCB& resize_cb,
+      const MmalCopiedFramedDestructionCB& destruction_cb) :
+#if TRACE_TRAMPOLINE
+    seq_(++seq_count_),
+#endif
+    in_flight_(0),
+    low_traced_(true),
+    max_in_flight_(max_in_flight),
+    resize_cb_(resize_cb),
+    destruction_cb_(destruction_cb)
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "@@@ " <<  __func__ << "[" << seq_ << "]";
+#endif
+  }
+
+  VideoFrame::MmalResizeCB new_resize_cb()
+  {
+    return base::Bind(&MmalTrampoline::resize_trampoline, this);
+  }
+
+  void kill()
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "--- "  << "[" << seq_ << "] Trampoline::kill";
+#endif
+    base::AutoLock lock(lock_);
+    resize_cb_.Reset();
+    destruction_cb_.Reset();
+    frame_stash_.alloc_frame(0); // Will flush out anything we have stashed
+  }
+
+  void free_frame(FrameDesc * const frame, const int buffer_count)
+  {
+    lock_.Acquire();
+
+    // Some callbacks can call us back
+    // We don't have recursive locks - so copy the callback for later use
+    // outside the lock
+    const MmalCopiedFramedDestructionCB cb = destruction_cb_;
+
+    frame_stash_.free_frame(frame);
+
+    // in_flight_ can exceed max_in_flight_ by the number of frames
+    // that can fit in the mmal port.  Avoid stuffing more than we have had returned.
+    const int stuff_count = std::min(in_flight_ - max_in_flight_, buffer_count);
+
+    if ((in_flight_ -= buffer_count) < 0)
+      LOG(FATAL) << "Buffers in flight underflow";
+
+#if TRACE_TRAMPOLINE
+    LOG(ERROR)  << "[" << seq_ << "] killed=" << destruction_cb_.is_null() << ", in_flight:" << in_flight_ << "/" << max_in_flight_ <<
+      ", BCount=" << buffer_count <<
+      ", Stuff=" << stuff_count;
+#endif
+    // Some hysteresis on in_flight logging - do not log if killed
+    if (in_flight_ < max_in_flight_ / 2 && !low_traced_ && !cb.is_null()) {
+      low_traced_ = true;
+      LOG(INFO) << "--- In flight low: " << in_flight_ << "/" << max_in_flight_;
+    }
+    else if (in_flight_ >= max_in_flight_ - 1 && low_traced_) {
+      low_traced_ = false;
+      LOG(INFO) << "--- In flight OK: " << in_flight_ << "/" << max_in_flight_;
+    }
+
+    lock_.Release();
+
+    if (stuff_count > 0 && !cb.is_null())
+      cb.Run(std::min(buffer_count, stuff_count));
+  }
+
+  FrameDesc * alloc_frame(const size_t size)
+  {
+    base::AutoLock lock(lock_);
+    return frame_stash_.alloc_frame(size);
+  }
+
+  bool recycle_buffer_in_flight(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    lock_.Acquire();
+    const bool wants_recycle = (++in_flight_ <= max_in_flight_);
+    lock_.Release();
+
+    if (wants_recycle)
+    {
+#if TRACE_TRAMPOLINE
+      LOG(ERROR) << "[" << seq_ << "] recycle: in flight=" << in_flight_;
+#endif
+      return true;
+    }
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "[" << seq_ << "] release, in_flight=" << in_flight_;
+#endif
+
+    // Was Deadlock opportunity
+    // ?? pool starvation opportunity now
+
+    buffer_release(buffer);
+    return false;
+  }
+
+  bool is_stalling() const
+  {
+    return in_flight_ >= max_in_flight_;
+  }
+};
+
+#if TRACE_TRAMPOLINE
+int MmalTrampoline::seq_count_ = 0;
+#endif
+
+//-----------------------------------------------------------------------------
+
+MmalVideoFrame::MmalVideoFrame(
+    const StorageType storage_type,
+    const gfx::Size& coded_size,
+    const gfx::Rect& visible_rect,
+    const gfx::Size& natural_size,
+    const base::TimeDelta timestamp,
+    const gpu::Mailbox& id) :
+  VideoFrame(PIXEL_FORMAT_MMAL_BUFFER, storage_type, coded_size, visible_rect, natural_size, timestamp),
+  id_(id)
+//  shmid_(-1)
+{
+}
+
+MmalVideoFrame::~MmalVideoFrame()
+{
+}
+
+//-----------------------------------------------------------------------------
+
+class MmalCopiedVideoFrame : public media::MmalVideoFrame
+{
+  scoped_refptr<MmalTrampoline> trampoline_;
+  FrameDesc * frame_desc_;
+  int buffer_count_;
+
+  ~MmalCopiedVideoFrame() override;
+
+public:
+  MmalCopiedVideoFrame(const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Size& size,
+      const base::TimeDelta timestamp = kNoTimestamp) :
+    MmalVideoFrame(
+      STORAGE_UNOWNED_MEMORY, size, gfx::Rect(size), size, timestamp),
+    trampoline_(trampoline),
+    buffer_count_(0)
+  {
+    // Allow 1 line overread (see VideoFrame::AllocateYUV)
+    const size_t height = RoundUp(rows(0) + 1, kFrameSizeAlignment * 2);
+    const size_t stride = RoundUp(row_bytes(0), kFrameSizeAlignment);
+    const size_t data_size = height * stride + kFrameSizePadding;
+
+    frame_desc_ = trampoline_->alloc_frame(data_size);
+    set_data(0, frame_desc_->frame());
+    set_stride(0, stride);
+    AddSharedMemoryHandle(frame_desc_->shared_memory());
+//    shmid_ = frame_desc_->shmid();
+    id_ = frame_desc_->get_id();
+
+    mmal_resize_cb_ = trampoline_->new_resize_cb();
+  }
+
+  void inc_buffer_count()
+  {
+    ++buffer_count_;
+  }
+};
+
+MmalCopiedVideoFrame::~MmalCopiedVideoFrame()
+{
+  frame_desc_->set_id_and_kill_cb(id_, kill_id_);
+  trampoline_->free_frame(frame_desc_, buffer_count_);
+}
+
+//-----------------------------------------------------------------------------
+//
+// VideoFrame class that deals with the case where the frame is copied into
+// an mmal buffer by the firmware and we then move the frame buffer from the mmal
+// buffer header to our frame.  This requires more careful buffer management than
+// the copy or zero variations.  See MmalFramePool for the buffer pool logic.
+
+class MmalStashedVideoFrame : public media::MmalVideoFrame
+{
+  scoped_refptr<MmalTrampoline> trampoline_;
+  FrameDesc * const frame_desc_;
+  const int buffer_count_;
+
+  ~MmalStashedVideoFrame() override;
+
+public:
+  // Create a VideoFrame and move the frame stash into it from
+  // the mmal buffer
+  MmalStashedVideoFrame(MMAL_BUFFER_HEADER_T * const buffer,
+      const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Size& size,
+      const size_t stride,
+      const base::TimeDelta timestamp = kNoTimestamp) :
+    MmalVideoFrame(
+      STORAGE_UNOWNED_MEMORY, size, gfx::Rect(size), size, timestamp,
+        ((const FrameDesc *)buffer->user_data)->get_id()),
+    trampoline_(trampoline),
+    frame_desc_((FrameDesc *)buffer->user_data),
+    buffer_count_(1)
+  {
+    set_data(0, buffer->data);
+    set_stride(0, stride);
+    AddSharedMemoryHandle(frame_desc_->shared_memory());
+//    shmid_ = frame_desc_->shmid();
+
+    buffer->data = nullptr;
+    buffer->alloc_size = 0;
+    buffer->user_data = nullptr;
+
+//    LOG(ERROR) << "@@@ " << __func__ << ", fd=" << frame_desc_->shared_memory().fd;
+
+    mmal_resize_cb_ = trampoline_->new_resize_cb();
+  }
+};
+
+MmalStashedVideoFrame::~MmalStashedVideoFrame()
+{
+//  LOG(ERROR) << "@@@ " << __func__ << ", fd=" << frame_desc_->shared_memory().fd << ", pid=" << getpid();
+  frame_desc_->set_id_and_kill_cb(id_, kill_id_);
+  trampoline_->free_frame(frame_desc_, buffer_count_);
+}
+
+//-----------------------------------------------------------------------------
+
+class MmalZeroVideoFrame : public media::MmalVideoFrame
+{
+  const base::Closure destruction_cb_;
+
+  ~MmalZeroVideoFrame() override;
+
+public:
+  MmalZeroVideoFrame(
+      const gfx::Size& size,
+      uint8_t * const data,
+      size_t stride,
+      const MmalResizeCB& resize_cb,
+      const base::Closure& destruction_cb,
+      const base::TimeDelta timestamp = kNoTimestamp) :
+    MmalVideoFrame(
+      STORAGE_UNOWNED_MEMORY, size, gfx::Rect(size), size, timestamp),
+    destruction_cb_(destruction_cb)
+  {
+    set_data(0, data);
+    set_stride(0, stride);
+    mmal_resize_cb_ = resize_cb;
+  }
+};
+
+MmalZeroVideoFrame::~MmalZeroVideoFrame()
+{
+  destruction_cb_.Run();
+}
+
+// ----------------------------------------------------------------------------
+
+class VcGenCmd {
+  bool init_good;
+  VCHI_INSTANCE_T vchi_instance;
+  VCHI_CONNECTION_T *vchi_connection = nullptr;
+
+public:
+  VcGenCmd() :
+    init_good(false),
+    vchi_instance(0),
+    vchi_connection(nullptr)
+  {
+    if (vchi_initialise(&vchi_instance) != 0) {
+      LOG(ERROR) << "VCHI initialization failed";
+      return;
+    }
+
+    //create a vchi connection
+    if (vchi_connect(NULL, 0, vchi_instance) != 0) {
+      LOG(ERROR) << "VCHI connection failed";
+      return;
+    }
+
+    vc_vchi_gencmd_init(vchi_instance, &vchi_connection, 1);
+    init_good = true;
+  }
+
+  ~VcGenCmd()
+  {
+    if (init_good) {
+      int err;
+
+      vc_gencmd_stop();
+
+      //close the vchi connection
+      if ((err = vchi_disconnect(vchi_instance)) != 0) {
+        LOG(ERROR) << "VCHI disconnect failed, err=" << err;
+      }
+    }
+  }
+
+  size_t get_memory_gpu() const
+  {
+    int err;
+
+    if (!init_good) {
+      return 0;
+    }
+
+    //send the gencmd for the argument
+    if ((err = vc_gencmd_send("get_mem gpu")) != 0) {
+      LOG(ERROR) << "vc_gencmd_send returned " << err;
+      return 0;
+    }
+
+    char rbuf[1024] = {0};
+    if ((err = vc_gencmd_read_response(rbuf, sizeof(rbuf) - 1)) != 0) {
+      LOG(ERROR) << "vc_gencmd_read_response returned " << err;
+      return 0;
+    }
+
+    if (strncmp(rbuf, "gpu=", 4) != 0) {
+      LOG(ERROR) << "Unexpected response for get_mem gpu: '" << rbuf << "'";
+      return 0;
+    }
+
+    char * p;
+    unsigned long m = strtoul(rbuf + 4, &p, 10);
+
+    if (p[0] != 'M' || p[1] !='\0') {
+      LOG(ERROR) << "Unexpected numeric for get_mem gpu: '" << rbuf << "'";
+      return 0;
+    }
+
+    return m << 20;
+  }
+};
+
+class MmalVcInit : public base::RefCountedThreadSafe<MmalVcInit>
+{
+  static base::Lock lock_;
+  static int ref_count_;
+
+  // Firmware & gpu_mem aren't going to change mid run so read once and
+  // use everywhere
+  static uint32_t firmware_date_;
+  static size_t gpu_mem_;
+
+  bool init_done_;
+
+  friend base::RefCountedThreadSafe<MmalVcInit>;
+  virtual ~MmalVcInit()
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ Destroy MmalVcInit done=" << init_done_ << ", count=" << ref_count_;
+#endif
+
+    if (init_done_) {
+      base::AutoLock lock(lock_);
+      if (--ref_count_ == 0) {
+        mmal_vc_deinit();
+      }
+    }
+  }
+
+  MmalVcInit(const bool single_process) :
+    init_done_(false)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ Create MmalVcInit";
+#endif
+
+    base::AutoLock lock(lock_);
+
+    // Already done?
+    if (ref_count_ != 0)
+    {
+      ++ref_count_;
+      init_done_ = true;
+      return;
+    }
+
+    int vfd = -1;
+    if (!single_process) {
+      base::Pickle request;
+      request.WriteInt(service_manager::SandboxLinux::METHOD_OPEN_DEV_VCHIQ);
+
+      uint8_t reply_buf[512];
+      const ssize_t reply_len = base::UnixDomainSocket::SendRecvMsg(
+          ipc_fd(), reply_buf, sizeof(reply_buf), &vfd, request);
+
+      if (reply_len == -1 || vfd == -1) {
+        LOG(ERROR) << "### Failed to open /dev/vchiq";
+        return;
+      }
+
+      // * Single process version of this?
+      base::Pickle reply(reinterpret_cast<char *>(reply_buf), reply_len);
+      base::PickleIterator pickle_iter(reply);
+      if (!pickle_iter.ReadUInt32(&firmware_date_))
+      {
+        LOG(ERROR) << "### Failed to get firmware date";
+      }
+    }
+
+    MMAL_STATUS_T err = mmal_vc_init_fd(vfd);
+
+    // The passed fd is at a minimum duped so close now
+    // we want to close on error too
+    IGNORE_EINTR(close(vfd));
+
+    if (err != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_vc_init_fd failed: fd=" << vfd << ", err=" << err;
+      return;
+    }
+
+    ++ref_count_;
+    init_done_ = true;
+
+    gpu_mem_ = VcGenCmd().get_memory_gpu();
+  }
+
+public:
+  static scoped_refptr<MmalVcInit> Init(const bool single_process)
+  {
+    scoped_refptr<MmalVcInit> vci(new MmalVcInit(single_process));
+
+    if (!vci->init_done_)
+      return nullptr;
+
+    return vci;
+  }
+
+  uint32_t firmware_date() const
+  {
+    return firmware_date_;
+  }
+
+  uint32_t gpu_mem() const
+  {
+    return gpu_mem_;
+  }
+};
+
+
+base::Lock MmalVcInit::lock_;
+int MmalVcInit::ref_count_ = 0;
+uint32_t MmalVcInit::firmware_date_;
+size_t MmalVcInit::gpu_mem_;
+
+// ----------------------------------------------------------------------------
+
+// Pool base class - can be instantiated
+class MmalPool
+{
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+public:
+  typedef base::Callback<bool(MMAL_BUFFER_HEADER_T * buffer)> MmalPoolBufferReleaseCB;
+
+private:
+  MmalPoolBufferReleaseCB pool_cb_;
+
+protected:
+  virtual bool do_pool_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    return pool_cb_.Run(buffer);
+  }
+
+private:
+  static MMAL_BOOL_T static_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata)
+  {
+    return ((MmalPool *)userdata)->do_pool_cb(buffer);
+  }
+
+protected:
+  MMAL_POOL_T * pool_;
+
+  MmalPool(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    pool_(nullptr)
+  {
+  }
+
+  // Must be called as part of create if you ever want callbacks to work
+  void set_static_pool_cb()
+  {
+    mmal_pool_callback_set(pool_, static_pool_cb, this);
+  }
+
+public:
+  // N.B. Overriding classes are responsible for freeing pool_ correctly
+  virtual ~MmalPool()
+  {
+  }
+
+  void set_buffer_release_cb(const MmalPoolBufferReleaseCB& cb)
+  {
+    pool_cb_ = cb;
+  }
+
+  virtual MMAL_BUFFER_HEADER_T * get_timeout(const uint32_t timeout_ms)
+  {
+    return mmal_queue_timedwait(pool_->queue, timeout_ms);
+  }
+
+  virtual MMAL_BUFFER_HEADER_T * get()
+  {
+    return mmal_queue_get(pool_->queue);
+  }
+
+  virtual void put(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_queue_put(pool_->queue, buffer);
+  }
+
+  // Do the equivalent of put then get
+  // Will refresh buffer->data if required
+  virtual MMAL_BUFFER_HEADER_T * put_get(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    return buffer;
+  }
+
+  uint32_t length() const
+  {
+    return mmal_queue_length(pool_->queue);
+  }
+
+  // Pool size (not data size)
+  uint32_t size() const
+  {
+    return pool_->headers_num;
+  }
+
+  // Thing we are servicing may have changed shape
+  // By default ignore
+  virtual int port_resized(const uint32_t num, const uint32_t size)
+  {
+    return 0;
+  }
+
+  virtual int create(const uint32_t num, const uint32_t size) = 0;
+
+  // Enable/disable aren't required fns but add helpful hints
+  // to some derived classes
+  // * Could be used to debug unexpected pool movement
+  virtual int disable()
+  {
+    return 0;
+  }
+
+  virtual int enable()
+  {
+    return 0;
+  }
+
+  // This isn't exactly part of a base pool implementation
+  // but it saves a spurious extra layer
+  virtual void set_trampoline(const scoped_refptr<MmalTrampoline>& trampoline)
+  {
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool attached to a port
+class MmalPortPool : public MmalPool
+{
+  MMAL_PORT_T * const port_;
+public:
+  MmalPortPool(const scoped_refptr<MmalVcInit>& vc_init, MMAL_PORT_T * const port) :
+    MmalPool(vc_init),
+    port_(port)
+  {
+  }
+
+  ~MmalPortPool() override
+  {
+    if (pool_ != NULL) {
+      mmal_port_pool_destroy(port_, pool_);
+    }
+  }
+
+  int create(const uint32_t num, const uint32_t size) override
+  {
+    if ((pool_ = mmal_port_pool_create(port_, num, size)) == NULL)
+    {
+      LOG(ERROR) << "### mmal_port_pool_create failed: " << num << "*" << size;
+      return -1;
+    }
+    set_static_pool_cb();
+    return 0;
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool not attached to a port
+
+class MmalUserPool : public MmalPool
+{
+public:
+  MmalUserPool(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalPool(vc_init)
+  {
+  }
+
+  ~MmalUserPool() override
+  {
+    if (pool_ != NULL) {
+      mmal_pool_destroy(pool_);
+    }
+  }
+
+  int create(const uint32_t num, const uint32_t size) override
+  {
+    if ((pool_ = mmal_pool_create(num, size)) == NULL)
+    {
+      LOG(ERROR) << "### mmal_pool_create failed: " << num << "*" << size;
+      return -1;
+    }
+    set_static_pool_cb();
+    return 0;
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool that has detachable frame buffers allocated by our trampoline
+// Buffers in the pool have no frame buffers attached
+// Buffers are attached on get and detached on release
+// * For a more generic version we could have callback alloc/free fns
+class MmalFramePool : public MmalUserPool
+{
+  scoped_refptr<MmalTrampoline> trampoline_;
+  size_t size_;
+
+  MMAL_BUFFER_HEADER_T * attach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    // Ignore null
+    if (buffer != nullptr) {
+      if (buffer->data != NULL) {
+        LOG(FATAL) << "Buffer already in use";
+      }
+
+      FrameDesc * frame;
+      if ((frame = trampoline_->alloc_frame(size_)) == nullptr)
+      {
+        LOG(ERROR) << "### " << __func__ << ": alloc frame failed";
+        // If we cannot alloc then release buffer back to pool as we are about
+        // to lose track of it
+        buffer_release(buffer);
+        return nullptr;
+      }
+      buffer->user_data = frame;
+      buffer->data = frame->frame();
+      buffer->alloc_size = frame->size();
+    }
+    return buffer;
+  }
+
+  MMAL_BUFFER_HEADER_T * detach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer != nullptr && buffer->data != nullptr) {
+      // This is called on buffer release so should have no "in-flight" component
+      trampoline_->free_frame((FrameDesc *)buffer->user_data, 0);
+      buffer->user_data = nullptr;
+      buffer->data = nullptr;
+      buffer->alloc_size = 0;
+    }
+    return buffer;  // For convienience
+  }
+
+protected:
+  bool do_pool_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    return MmalUserPool::do_pool_cb(detach_data_buffer(buffer));
+  }
+
+public:
+  MmalFramePool(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalUserPool(vc_init),
+    size_(0)
+  {
+  }
+
+  int create(const uint32_t num, const uint32_t size) override
+  {
+    if (MmalUserPool::create(num, 0) != 0) {
+      return -1;
+    }
+    size_ = size;
+    return 0;
+  }
+
+  MMAL_BUFFER_HEADER_T * get_timeout(const uint32_t timeout_ms) override
+  {
+    return attach_data_buffer(MmalUserPool::get_timeout(timeout_ms));
+  }
+
+  MMAL_BUFFER_HEADER_T * get() override
+  {
+    return attach_data_buffer(MmalUserPool::get());
+  }
+
+  void put(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    MmalUserPool::put(detach_data_buffer(buffer));
+  }
+
+  // This is effectively a realloc to the current size and will
+  // attach a buffer if none was attached before
+  // Useful when recycling a buffer directly back into a port
+  MMAL_BUFFER_HEADER_T * put_get(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    if (buffer->alloc_size == size_)
+      return buffer;
+
+    return attach_data_buffer(detach_data_buffer(buffer));
+  }
+
+  int disable() override
+  {
+    // Avoid keeping an otherwise unused trampoline alive longer than needed
+    trampoline_ = nullptr;
+    return MmalUserPool::disable();
+  }
+
+  int port_resized(const uint32_t num, const uint32_t size) override
+  {
+    // Remember for future allocation and that is all we want to do
+    size_ = size;
+    return 0;
+  }
+
+  // As this has no locking this should only be called when disabled
+  // (in most cases this means that the port we are servicing is disabled)
+  void set_trampoline(const scoped_refptr<MmalTrampoline>& trampoline) override
+  {
+    trampoline_ = trampoline;
+  }
+};
+
+//=============================================================================
+//
+// Wrapper for an mmal port
+
+class MmalPort
+{
+  // Actually connection should be a subclass?
+  friend class MmalConnection;
+
+protected:
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+public:
+  MMAL_PORT_T * port_;
+  bool killing_;
+
+  virtual void event_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    LOG(ERROR) << "### Unexpected ES data";
+    mmal_buffer_header_release(buffer);
+  }
+
+  virtual void cmd_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd == MMAL_EVENT_ERROR) {
+        LOG(WARNING) << "### Mmal reports error " << *(uint32_t *)buffer->data;
+    } else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {
+      mmal_log_dump_port(port_);
+      const MMAL_EVENT_FORMAT_CHANGED_T *const fc = mmal_event_format_changed_get(buffer);
+      LOG(INFO) << "Mmal format changed: size_min:" << fc->buffer_size_min <<
+        ", num_min:" << fc->buffer_num_min <<
+          ", size_rec:" << fc->buffer_size_recommended <<
+          ", num_rec:" << fc->buffer_num_recommended;
+      if (fc->format != NULL) {
+        mmal_log_dump_format(fc->format);
+      }
+    } else {
+        char s[20];
+        LOG(WARNING) << "### Mmal unexpected command: " << mmal_4cc_to_string(s, sizeof(s), buffer->cmd);
+    }
+
+    // Commands are allocated from a different pool to ES data
+    // return to sender...
+    mmal_buffer_header_release(buffer);
+  }
+
+private:
+  void callback_common(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd != 0) {
+      // Cmd buffers are not allocated from the main pool
+      cmd_cb(buffer);
+    }
+    else
+    {
+      if (killing_) {
+        // If flushing always release the buffer
+        mmal_buffer_header_release(buffer);
+      }
+      else {
+        event_cb(buffer);
+      }
+    }
+  }
+
+  static void callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    MmalPort *p = static_cast<MmalPort*>((void*)port->userdata);
+
+    if (p == NULL) {
+      LOG(ERROR) << __func__ << "### Port NULL";
+    }
+    else
+    {
+      p->callback_common(buffer);
+    }
+  }
+
+public:
+  virtual int enable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (killing_) {
+      LOG(ERROR) << "### port enable when killed";
+      return -1;
+    }
+
+    if ((err = mmal_port_enable(port_, callback)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  virtual int disable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (port_ != NULL && port_->is_enabled) {
+      err = mmal_port_disable(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  bool is_enabled() const
+  {
+    return port_ != nullptr && port_->is_enabled;
+  }
+
+  virtual int commit()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if ((err = mmal_port_format_commit(port_)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### mmal_port_format_commit failed: err=" << err;
+      mmal_log_dump_port(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  uint32_t buffer_size() const
+  {
+    return port_->buffer_size;
+  }
+
+  uint32_t buffer_num() const
+  {
+    return port_->buffer_num;
+  }
+
+  // This set of fns are overridden by MmalConnectedPort
+  // to provide max of connected ports
+  virtual uint32_t buffer_size_recommended() const
+  {
+    return port_->buffer_size_recommended;
+  }
+
+  virtual uint32_t buffer_size_min() const
+  {
+    return port_->buffer_size_recommended;
+  }
+
+  virtual uint32_t buffer_num_recommended() const
+  {
+    return port_->buffer_num_recommended;
+  }
+
+  virtual uint32_t buffer_num_min() const
+  {
+    return port_->buffer_num_min;
+  }
+
+  virtual int set_buffers(const uint32_t size, const uint32_t num)
+  {
+    port_->buffer_num = num;
+    port_->buffer_size = size;
+    return 0;
+  }
+
+  int set_buffers_recommended()
+  {
+    return set_buffers(buffer_size_recommended(), buffer_num_recommended());
+  }
+
+  int set_parameter(const uint32_t param, const uint32_t val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_uint32(port_, param, val)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_uint32 failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  inline int set_parameter(const uint32_t param, const int val) const
+  {
+    return set_parameter(param, (uint32_t)(val));
+  }
+
+  int set_parameter(const uint32_t param, const bool val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_boolean(port_, param, val ? MMAL_TRUE : MMAL_FALSE)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_boolean failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int get_parameter(MMAL_PARAMETER_HEADER_T * const param) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_get(port_, param)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_get failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // class for storing the supported encodings parameter info
+  class SupportedEncodings
+  {
+    static const int max_encodings_ = 64;
+    struct {
+       MMAL_PARAMETER_HEADER_T header_;
+       MMAL_FOURCC_T encodings_[max_encodings_];
+    } supported_;
+    int n_;
+
+  public:
+    typedef const MMAL_FOURCC_T * iterator;
+
+    SupportedEncodings(const MmalPort& port) :
+      supported_({{MMAL_PARAMETER_SUPPORTED_ENCODINGS, sizeof(supported_)}, {0}}),
+      n_(-1)
+    {
+      if (port.get_parameter(&supported_.header_) == 0)
+      {
+        n_ = (supported_.header_.size - sizeof(supported_.header_)) /
+          sizeof(supported_.encodings_[0]);
+      }
+    }
+
+    virtual ~SupportedEncodings()
+    {
+    }
+
+    // Default copy is OK
+
+    iterator begin() const
+    {
+      return supported_.encodings_;
+    }
+
+    iterator end() const
+    {
+      return supported_.encodings_ + n_;
+    }
+
+    bool is_supported(const MMAL_FOURCC_T x) const
+    {
+      // If we end up doing this a lot for any reason then use a better lookup
+      for (auto &enc : *this) {
+        if (x == enc) {
+          return true;
+        }
+      }
+      return false;
+    }
+
+    std::string ToString() const
+    {
+      std::ostringstream s;
+      for (int i = 0; i < n_; ++i) {
+        char buf[8];
+        if (i != 0)
+          s << ",";
+        s << mmal_4cc_to_string(buf, sizeof(buf), supported_.encodings_[i]);
+      }
+      return s.str();
+    }
+  };
+
+  SupportedEncodings get_parameter_supported_encodings() const
+  {
+    return SupportedEncodings(*this);
+  }
+
+  static MMAL_FOURCC_T color_space_to_mmal(const ColorSpace color_space)
+  {
+    switch (color_space) {
+      case ColorSpace::COLOR_SPACE_JPEG:
+        return MMAL_COLOR_SPACE_JPEG_JFIF;
+      case ColorSpace::COLOR_SPACE_HD_REC709:
+        return MMAL_COLOR_SPACE_ITUR_BT709;
+      case ColorSpace::COLOR_SPACE_SD_REC601:
+        return MMAL_COLOR_SPACE_ITUR_BT601;
+      case ColorSpace::COLOR_SPACE_UNSPECIFIED:
+        return MMAL_COLOR_SPACE_UNKNOWN;
+    }
+    return MMAL_COLOR_SPACE_UNKNOWN;
+  }
+
+  int set_video_encoding(
+    const MMAL_FOURCC_T encoding,
+    const MMAL_FOURCC_T encoding_variant = MMAL_ENCODING_VARIANT_DEFAULT,
+    const uint32_t flags = 0)
+  {
+    MMAL_ES_FORMAT_T *const format = port_->format;
+
+    format->type = MMAL_ES_TYPE_VIDEO;
+    format->encoding = encoding;
+    format->encoding_variant = encoding_variant;
+    format->flags = 0;
+    format->bitrate = 0;
+    return 0;
+  }
+
+  // Fill in all of a MMAL_VIDEO_FORMAT_T
+  int set_video_format(
+      const gfx::Size& size,
+      const gfx::Rect& crop,
+      const gfx::Size& par = gfx::Size(),
+      const ColorSpace color_space = ColorSpace::COLOR_SPACE_UNSPECIFIED) const
+  {
+    MMAL_ES_FORMAT_T *const format = port_->format;
+    MMAL_VIDEO_FORMAT_T *const video = &format->es->video;
+    const bool isyuv = format->encoding == MMAL_ENCODING_I420;
+
+    const uint32_t w = size.width();
+    const uint32_t h = size.height();
+
+    video->width = VCOS_ALIGN_UP(w, isyuv ? 32 : 16);
+    video->height = VCOS_ALIGN_UP(h, 16);
+    video->crop.x = crop.x();
+    video->crop.y = crop.y();
+    video->crop.width = crop.width();
+    video->crop.height = crop.height();
+    video->frame_rate.num = 30000;  // Not in config - make something valid up
+    video->frame_rate.den = 1001;
+    video->par.num = par.width();
+    video->par.den = par.height();
+    video->color_space = color_space_to_mmal(color_space);
+    return 0;
+  }
+
+  // Disable once we forget about it
+  virtual ~MmalPort()
+  {
+    disable();
+  }
+
+  MmalPort(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    port_(NULL),
+    killing_(false)
+  {
+  }
+
+  virtual void set_port(MMAL_PORT_T * const port)
+  {
+    if (port_ != NULL) {
+      LOG(ERROR) << "### Port not null";
+      return;
+    }
+
+    port->userdata = (struct MMAL_PORT_USERDATA_T *)(void *)this;
+    port_ = port;
+  }
+
+  // Submit a buffer - on failure (or kill) buffer is released
+  int submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    MMAL_STATUS_T err;
+
+    if (killing_ || !port_->is_enabled) {
+      mmal_buffer_header_release(buffer);
+      return 0;
+    }
+
+    if ((err = mmal_port_send_buffer(port_, buffer)) != MMAL_SUCCESS)
+    {
+      // Release buffer on error
+      mmal_buffer_header_release(buffer);
+      LOG(ERROR) << "#### mmal_send_buffer (" << buffer << ") failed: err=" << err;
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  void kill()
+  {
+    killing_ = true;
+    disable();
+  }
+
+  void dump_video_format()
+  {
+    const MMAL_ES_FORMAT_T * const format = port_->format;
+    const MMAL_VIDEO_FORMAT_T *const video = &format->es->video;
+    char buf1[10], buf2[10];
+
+    LOG(ERROR) << port_->name << ": Encoding:" << mmal_4cc_to_string(buf1, sizeof(buf1), format->encoding) <<
+    ":" << mmal_4cc_to_string(buf2, sizeof(buf2), format->encoding_variant) <<
+        ", " << video->width << "x" << video->height <<
+        ", crop: " << video->crop.x << "," << video->crop.y <<
+        " " << video->crop.width << "x" << video->crop.height;
+  }
+
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalConnection : public base::RefCountedThreadSafe<MmalConnection>
+{
+  friend MmalConnectedPort;
+
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+  bool enabled_;
+  MMAL_CONNECTION_T * connection_;
+  MmalConnectedPort * src_;
+  MmalConnectedPort * dest_;
+
+  friend base::RefCountedThreadSafe<MmalConnection>;
+  virtual ~MmalConnection()
+  {
+    if (connection_ != NULL) {
+      mmal_connection_destroy(connection_);
+    }
+  }
+
+  MmalConnection(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    enabled_(false),
+    connection_(NULL),
+    src_(NULL),
+    dest_(NULL)
+  {
+  }
+
+  void disconnect();
+  int connect(MmalConnectedPort * const src, MmalConnectedPort * const dest);
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if (enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    if ((err = mmal_connection_enable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_enable failed: err=" << err;
+      return -1;
+    }
+
+    enabled_ = true;
+    return 0;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+
+    if (!enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    // Mark as disabled even if we fail as in this case I have no idea how
+    // to recover and retry is very unlikely to help
+    enabled_ = false;
+
+    if ((err = mmal_connection_disable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_disable failed: err=" << err;
+      return -1;
+    }
+
+    return 0;
+  }
+
+  uint32_t buffer_size_recommended() const;
+  uint32_t buffer_num_recommended() const;
+  uint32_t buffer_size_min() const;
+  uint32_t buffer_num_min() const;
+  int set_buffers(uint32_t s, uint32_t n);
+};
+
+// ----------------------------------------------------------------------------
+//
+// Port that we are expecting to be attached to another port by an MmalConnection
+
+class MmalConnectedPort : public MmalPort
+{
+  scoped_refptr<MmalConnection> connection_;
+
+public:
+  void set_connection(MmalConnection * connection)
+  {
+    connection_ = connection;
+  }
+
+  int disconnect()
+  {
+    if (connection_ != NULL) {
+      connection_->disconnect();
+    }
+    return 0;
+  }
+
+  int enable() override
+  {
+    return connection_->enable();
+  }
+
+  int disable() override
+  {
+    return connection_ == NULL ? 0 : connection_->disable();
+  }
+
+  int connect_to_src(MmalConnectedPort * const src)
+  {
+    scoped_refptr<MmalConnection> connection(new MmalConnection(vc_init_));
+    return connection->connect(src, this);
+  }
+
+  uint32_t buffer_size_recommended() const override
+  {
+    return connection_->buffer_size_recommended();
+  }
+
+  uint32_t buffer_num_recommended() const override
+  {
+    return connection_->buffer_num_recommended();
+  }
+
+  uint32_t buffer_size_min() const override
+  {
+    return connection_->buffer_size_min();
+  }
+
+  uint32_t buffer_num_min() const override
+  {
+    return connection_->buffer_num_min();
+  }
+
+  int set_buffers(const uint32_t s, const uint32_t n) override
+  {
+    return connection_->set_buffers(s, n);
+  }
+
+  MmalConnectedPort(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalPort(vc_init)
+  {
+  }
+
+  ~MmalConnectedPort() override
+  {
+    disconnect();
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalPortAndPool : public MmalPort
+{
+  typedef scoped_refptr<MmalPortAndPool> AutoRef;
+
+  MmalComponent * const component_;
+
+  std::unique_ptr<MmalPool> pool_;
+
+public:
+  // These allow us to use scoped_refptr on this object
+  // They trampoline to the enclosing component
+  void AddRef() const;
+  void Release();
+
+  const MmalTaskRunner& task_runner() const;
+
+protected:
+  virtual void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) = 0;
+
+private:
+  static bool pool_cb(MmalPortAndPool * mpp, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    // As the release can cause us to commit suicide we must put the buffer
+    // back by hand before calling Release as if we try to do it afterwards
+    // the Q may have vanished and we would crash.
+    mpp->pool_->put(buffer);
+    mpp->Release();
+    return false;  // We did the put back ourselves
+  }
+
+  // Given that we now have ref counts that can hit zero when all buffers are
+  // returned to the pool ensure that we can't commit untimely suicide by
+  // holding a ref on ourselves until the callback is over.
+  // This could probably be ensured by careful coding of the overriding
+  // callbacks but this removes the possibility of unexpected surprises
+  void event_cb(MMAL_BUFFER_HEADER_T * const buffer) final
+  {
+    AutoRef(this)->buffer_event_cb(buffer);
+  }
+
+protected:
+  int set_pool(MmalPool *const pool, const uint32_t num)
+  {
+    pool_ = std::unique_ptr<MmalPool>(pool);
+    if (pool_->create(num, port_->buffer_size) != 0) {
+      return -1;
+    }
+    pool_->set_buffer_release_cb(base::Bind(MmalPortAndPool::pool_cb, this));
+    return 0;
+  }
+
+  int set_pool(MmalPool *const pool)
+  {
+    if (pool == nullptr) {
+      pool_ = nullptr;
+      return 0;
+    }
+    return set_pool(pool, port_->buffer_num);
+  }
+
+public:
+  template<typename T>
+  base::Callback<T> bind_to_task_runner(const base::Callback<T>& cb)
+  {
+    return base::Bind(&internal::TrampolineHelper<T>::Run,
+                      MmalTaskRunner(task_runner()), cb);
+  }
+  void task_run(const base::Closure& cb)
+  {
+    task_runner()->PostTask(FROM_HERE, cb);
+  }
+
+  MmalPortAndPool(const scoped_refptr<MmalVcInit>& vc_init, MmalComponent * const component) :
+    MmalPort(vc_init),
+    component_(component)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  ~MmalPortAndPool() override
+  {
+    disable();
+  }
+
+  int create_port_pool()
+  {
+    return set_pool(new MmalPortPool(vc_init_, port_));
+  }
+
+  int create_user_pool(const uint32_t buffer_num)
+  {
+    return set_pool(new MmalUserPool(vc_init_), buffer_num);
+  }
+
+  MMAL_BUFFER_HEADER_T * pool_get(const bool wait = false)
+  {
+    if (pool_ == NULL) {
+      LOG(ERROR) << "### Pool not set up\n";
+      return NULL;
+    }
+
+    MMAL_BUFFER_HEADER_T * const header =  wait ?
+      pool_->get_timeout(5000) : pool_->get();
+
+    if (header != NULL) {
+      AddRef();
+    }
+
+    return header;
+  }
+
+  int pool_size() const
+  {
+    return pool_->size();
+  }
+
+  int queue_length() const
+  {
+    return pool_->length();
+  }
+
+  // Stuff all the pool entries into the port
+  int stuff()
+  {
+    MMAL_BUFFER_HEADER_T * buffer;
+    while ((buffer = pool_get()) != NULL) {
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+  int stuff(int stuff_count, const bool wait = false)
+  {
+    while (--stuff_count >= 0)
+    {
+      MMAL_BUFFER_HEADER_T * buffer;
+      if ((buffer = pool_get(wait)) == NULL)
+      {
+        LOG(ERROR) << "### Unexpected pool_get_failure";
+        return -1;
+      }
+
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+  void recycle(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    submit(pool_->put_get(buffer));
+  }
+
+  int enable() override
+  {
+    if (pool_ == nullptr)
+    {
+      LOG(ERROR) << "MmalPoolAndPort::enable: pool NULL";
+      return -1;
+    }
+
+    if (pool_->port_resized(port_->buffer_num, port_->buffer_size) != 0 ||
+        pool_->enable() != 0)
+      return -1;
+
+    return MmalPort::enable();
+  }
+
+  int disable() override
+  {
+    const int rv = MmalPort::disable();
+    return (pool_ != nullptr && pool_->disable() != 0) ? -1 : rv;
+  }
+
+  int commit() override
+  {
+    const int rv = MmalPort::commit();
+    // ** Notify pool that size may have changed
+    return rv;
+  }
+
+  void set_trampoline(scoped_refptr<MmalTrampoline>& trampoline)
+  {
+    pool_->set_trampoline(trampoline);
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalVideoESPort : public MmalPortAndPool
+{
+  VideoDecoder::DecodeCB decode_cb_;
+  scoped_refptr<DecoderBuffer> submit_buffer_;
+  uint32_t submit_offset_;
+  bool low_delay_;
+
+public:
+  MmalVideoESPort(const scoped_refptr<MmalVcInit>& vc_init, MmalComponent * const component) :
+    MmalPortAndPool(vc_init, component),
+    low_delay_(false)
+  {
+  }
+  ~MmalVideoESPort() override
+  {
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+  }
+
+  // Only checks the codec type if we had to set the encoding bitmask
+  bool set_supported_video_codecs() const
+  {
+    if (supported_video_codecs != 0)
+      return false;
+
+    const MmalPort::SupportedEncodings encodings(get_parameter_supported_encodings());
+
+    // We always claim to support H264
+    unsigned int bits = 1 << VideoCodec::kCodecH264;
+
+    for (auto& enc : encodings) {
+      bits |= 1 << fourcc_to_video_codec(enc);
+    }
+
+    // Mask out unknown
+    supported_video_codecs = bits & ~(1 << VideoCodec::kUnknownVideoCodec);
+
+    LOG(INFO) << "Supported video encodings: " << encodings.ToString() << ", bits=" << std::hex << bits;
+    return true;
+  }
+
+  int config(const VideoDecoderConfig& config, const bool low_delay)
+  {
+    const VideoCodec codec = config.codec();
+
+    if (set_supported_video_codecs())
+    {
+      // We set the supported mask - check if we expect this to work...
+      // If we didn't set it then assume we have already checked
+      if ((supported_video_codecs & (1 << codec)) == 0) {
+        // return silently
+        return -1;
+      }
+    }
+
+    low_delay_ = low_delay;
+
+    const MMAL_FOURCC_T encoding = video_codec_to_fourcc(codec);
+
+    if (encoding == MMAL_ENCODING_UNKNOWN) {
+      LOG(ERROR) << "### Unexpected video codec:" << config.codec();
+      return -1;
+    }
+
+    set_video_encoding(encoding, MMAL_ENCODING_VARIANT_DEFAULT, MMAL_ES_FORMAT_FLAG_FRAMED);
+
+    set_video_format(config.coded_size(),
+        config.visible_rect(),
+        par_from_sizes(config.visible_rect().size(), config.natural_size()),
+        config.color_space());
+
+    return 0;
+  }
+
+private:
+  int submit_data(const uint8_t * const data, const uint32_t len,
+      const base::TimeDelta& pts,
+      const bool is_start, const bool not_pkt)
+  {
+    uint32_t bsent = 0;
+
+    MMAL_BUFFER_HEADER_T * const buffer = pool_get(not_pkt);
+    if (buffer == NULL) {
+      return 0;
+    }
+
+//    LOG(ERROR) << "-- submit len=" << len << ", pts=" << pts;
+
+    // resets length, offset, flags, pts, dts
+    mmal_buffer_header_reset(buffer);
+    buffer->cmd = 0;
+
+    if (data == NULL)
+    {
+        buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;
+        // As this is zero length avoid poking the data
+        bsent = 1; // 0 means did nothing so pick another number
+    }
+    else
+    {
+        if (is_start)
+        {
+            buffer->pts = (pts == kNoTimestamp) ? MMAL_TIME_UNKNOWN : pts.InMicroseconds();
+//            buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START | MMAL_BUFFER_HEADER_FLAG_USER0;
+        }
+
+        bsent = buffer->length = std::min(len, buffer->alloc_size);
+
+        if (mmal_buffer_header_mem_lock(buffer) != MMAL_SUCCESS)
+        {
+            LOG(ERROR) << "#### Cannot lock buffer";
+            buffer_release(buffer);
+            return -1;
+        }
+
+        memcpy(buffer->data, data, buffer->length);
+
+        mmal_buffer_header_mem_unlock(buffer);
+
+        if (len == bsent)
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+        if (not_pkt)
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;
+    }
+
+//    LOG(ERROR) << "Submit: flags=" << std::hex << buffer->flags << std::dec << ", len=" << buffer->length << ", pts=" << buffer->pts;
+
+    if (MmalPortAndPool::submit(buffer) != 0)
+    {
+      return -1;
+    }
+
+    return (int)bsent;
+  }
+
+  void submit_done(const DecodeStatus status)
+  {
+    VideoDecoder::DecodeCB cb(decode_cb_);
+
+    decode_cb_.Reset();
+    submit_buffer_ = NULL;
+
+//    LOG(ERROR) << ">>> decode_cb.Run(" << status << ")";
+    cb.Run(status);
+  }
+
+  void submit_poll()
+  {
+    if (submit_buffer_ == NULL) {
+//      LOG(ERROR) << "ES CB null";
+      return;
+    }
+
+    if (submit_buffer_->end_of_stream()) {
+      LOG(INFO) << "<<< EOS";
+
+      int bsent = submit_data(NULL, 0, kNoTimestamp, true, false);
+
+      if (bsent != 0)
+      {
+        decode_cb_.Reset();
+        submit_buffer_ = NULL;
+
+        // The callback on EOS takes place much later & from the resizer output
+      }
+    }
+    else
+    {
+//      LOG(ERROR) << "submit";
+      const uint32_t size = submit_buffer_->data_size();
+
+      while (submit_offset_ < size) {
+        const int bsent = submit_data(submit_buffer_->data() + submit_offset_,
+            size - submit_offset_,
+            submit_buffer_->timestamp(),
+            submit_offset_ == 0, false);
+
+//        LOG(ERROR) << "es submit bsent=" << bsent << ", pql=" << queue_length();
+
+        if (bsent <= 0)
+        {
+          if (bsent != 0)
+            submit_done(DecodeStatus::DECODE_ERROR);
+          return;
+        }
+
+        submit_offset_ += bsent;
+      }
+
+      // If we've got here then we've got a finished submit_buffer_
+      // wait for pool empty before signalling "next"
+      if (!low_delay_ || queue_length() == pool_size()) {
+//        LOG(ERROR) << "submit done";
+        submit_done(DecodeStatus::OK);
+      }
+    }
+  }
+
+  void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    buffer_release(buffer);
+
+    task_run(base::Bind(&MmalVideoESPort::submit_poll, this));
+  }
+
+
+public:
+  int submit(const scoped_refptr<DecoderBuffer>& buffer, const VideoDecoder::DecodeCB& decode_cb)
+  {
+    if (submit_buffer_ != NULL) {
+      LOG(ERROR) << "### Submit already active";
+      return -1;
+    }
+
+    if (decode_cb.is_null()) {
+      // If null CB then assume we need sync output
+      return submit_data(buffer->data(), buffer->data_size(), buffer->timestamp(), true, true) < 0 ? -1 : 0;
+    }
+    else
+    {
+      // * If we aren't in the same thread as task_runner_ at this point
+      //   then this lot is unsafe...
+
+      submit_buffer_ = buffer;
+      submit_offset_ = 0;
+      decode_cb_ = decode_cb;
+
+      submit_poll();
+    }
+    return 0;
+  }
+
+  int disable() override
+  {
+    // Get and kill any pending submit_callback
+    if (submit_buffer_ != NULL) {
+      submit_done(DecodeStatus::ABORTED);
+    }
+    return MmalPortAndPool::disable();
+  }
+};
+
+
+// ----------------------------------------------------------------------------
+//
+// * It might be nice to split this into ZC & Copy versions but as it stands
+//   the port is declared directly in the component which makes that tricky
+
+class MmalVideoARGBPort : public MmalPortAndPool
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size req_size_;
+  VideoDecoder::OutputCB output_cb_;
+  VideoDecoder::DecodeCB eos_cb_;
+  base::Lock resize_lock_;
+  bool red_pixel_;
+  scoped_refptr<MmalTrampoline> frame_trampoline_;
+  scoped_refptr<MmalCopiedVideoFrame> sliced_frame_;
+  int sliced_y_;
+  base::subtle::Atomic32 zc_buffers_in_flight_;
+  base::TimeDelta last_pts_;
+  bool debug_bench_;
+  bool resize_disabled_;
+
+  class FpS
+  {
+    // Average over this number of frames for running average
+    static const size_t avg_size_ = 128;
+
+    static uint64_t utime()
+    {
+      struct timespec ts;
+      clock_gettime(CLOCK_MONOTONIC, &ts);
+      return (uint64_t)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+    }
+
+    uint64_t start_time_;
+    uint64_t period_time_;
+    unsigned int frame_count_;
+
+    uint64_t time_stash_[avg_size_];
+    size_t stash_n_;
+
+    void do_start(const uint64_t now)
+    {
+      start_time_ = now;
+      period_time_ = now;
+      stash_n_ = 0;
+    }
+
+  public:
+    FpS() :
+      start_time_(0),
+      period_time_(0),
+      frame_count_(0),
+      time_stash_{0}
+    {
+    }
+
+    void start()
+    {
+      frame_count_ = 0;
+    }
+
+    void inc_frames()
+    {
+      const uint64_t now = utime();
+      if (frame_count_++ == 0)
+        do_start(now);
+      time_stash_[stash_n_] = now;
+      if (++stash_n_ >= avg_size_)
+        stash_n_ = 0;
+    }
+
+    bool period_expired(const uint64_t duration_us)
+    {
+      const uint64_t now = utime();
+      if (period_time_ + duration_us <= now) {
+        period_time_ += duration_us;
+        return true;
+      }
+      return false;
+    }
+
+    std::string ToString()
+    {
+      if (start_time_ == 0) {
+        return std::string("<uninit>");
+      }
+      const uint64_t now = utime();
+      if (start_time_ == now) {
+        return std::string("<inf>");
+      }
+
+      const uint64_t mFpS = ((uint64_t)frame_count_ * 1000000000) / (now - start_time_);
+      const uint64_t mFpS_avg = frame_count_ < avg_size_ ? 0 :
+        ((uint64_t)avg_size_ * 1000000000) / (now - time_stash_[stash_n_]);
+      std::ostringstream s;
+      s << frame_count_  << " @ "
+        << mFpS / 1000 << "." << std::setfill('0') << std::setw(3) << mFpS % 1000 << std::setw(0)
+        << ", avg: " << mFpS_avg / 1000 << "." << std::setfill('0') << std::setw(3) << mFpS_avg % 1000;
+
+      return s.str();
+    }
+  };
+
+  std::unique_ptr<FpS> fps_;
+
+  bool inline eos_pending() const
+  {
+    return !eos_cb_.is_null();
+  }
+
+  void kill_trampoline()
+  {
+    if (frame_trampoline_)
+    {
+      frame_trampoline_->kill();
+      frame_trampoline_ = NULL;
+    }
+  }
+
+  // Mostly required to discard the return value
+  void posted_submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << "--- " << __func__;
+    submit(buffer);
+  }
+
+  void recycle_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_buffer_header_reset(buffer);
+
+    if (resize_lock_.Try()) {
+      recycle(buffer);
+      resize_lock_.Release();
+    }
+    else
+    {
+      // Move the recycle onto the main thread which should be the one running
+      // the resize so no further locking required
+      //
+      // ??? Interaction with max_in_flight_ ???
+      task_run(base::Bind(&MmalVideoARGBPort::recycle, this, buffer));
+    }
+  }
+
+  // Unlocks buffer & recycles it
+  void zc_frame_destruction_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << __func__;
+    const base::subtle::Atomic32 n = base::subtle::NoBarrier_AtomicIncrement(&zc_buffers_in_flight_, -1);
+
+    if (n < pool_size() / 2) {
+      LOG(INFO) << "--- in flight low:" << n;
+    }
+
+    mmal_buffer_header_mem_unlock(buffer);
+    recycle_buffer(buffer);
+  }
+
+  // Called from trampoline on free_frame
+  // so may come from a random thread
+  void copied_frame_destruction_cb(const int buffer_count)
+  {
+    // stuff may have to wait for a buffer as the recycling
+    // cannot be protected by the trampoline lock with the current
+    // code so we have a race
+    if (stuff(buffer_count, true) == -1)
+      LOG(FATAL) << "No buffers to back up recycle request";
+  }
+
+  void resize_posted(const gfx::Size req_size)
+  {
+    if (req_size.width() <= 0 || req_size.height() <= 0 || req_size == size())
+      return;
+
+    LOG(INFO) << __func__ << "(" << req_size.ToString() << ")";
+
+    const bool was_enabled = is_enabled();
+
+    // Must avoid disable/enable if
+    //   (a) Already disabled
+    //   (b) EOS pending (will confuse the process)
+
+    if (eos_pending()) {
+      LOG(INFO) << __func__ << ": abort due to EOS";
+      // If EOS pending then do nothing - we shouldn't get more stream
+      // until at least a reset
+      // Reset req_size to whatever we are so we will get recalled if needed
+      // * Locking ??
+      req_size_ = size();
+      return;
+    }
+
+    if (was_enabled) {
+      disable();
+    }
+
+    base::AutoLock lock(resize_lock_);
+    set_size(req_size);
+    commit();
+    if (copy_mode_ == FrameCopyMode::FRAME) {
+      set_buffers(buffer_size_recommended(), buffer_num());
+#if !OPT_FRAME_COPY_STASHED
+      // In this case the allocation is done by mmal so we need to recreate the
+      set_pool(nullptr);  // Kill before realloc so we never have 2 sets alloce
+      create_port_pool();
+#endif
+    }
+
+    if (was_enabled)
+      enable();
+
+//    LOG(INFO) << __func__ << " done";
+  }
+
+  void resize_cb(const gfx::Size& size)
+  {
+//    LOG(ERROR) << __func__ << "(" << size.ToString() << ")";
+
+    if (size == req_size_ || resize_disabled_) {
+      return;
+    }
+    req_size_ = size;
+
+    // Avoid running in the callback - run on our own thread
+    task_run(base::Bind(&MmalVideoARGBPort::resize_posted, this, size));
+  }
+
+public:
+  gfx::Size size() const
+  {
+    return gfx::Size(port_->format->es->video.crop.width, port_->format->es->video.crop.height);
+  }
+
+private:
+
+  void mov_frame_block(const scoped_refptr<MmalCopiedVideoFrame>& frame,
+      MMAL_BUFFER_HEADER_T * const buffer,
+      const size_t stride,
+      const size_t width,
+      const size_t start_y,
+      const int lines)
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_buffer_header_mem_lock(buffer)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### Unable to lock buffer; err=" << err;
+      return;
+    }
+
+    const uint8_t * s = buffer->data + buffer->type->video.offset[0];
+    const size_t d_stride = frame->stride(0);
+    uint8_t * d = frame->data(0) + start_y * d_stride;
+    const size_t line_size = width * 4;
+
+    for (int i = 0; i < lines; ++i, s += stride, d += d_stride)
+      memcpy(d, s, line_size);
+
+    // Unlock & recycles
+    mmal_buffer_header_mem_unlock(buffer);
+
+    // Count buffers used by this frame
+    frame->inc_buffer_count();
+
+    if (frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+      recycle_buffer(buffer);
+    }
+  }
+
+  void emit_copied_frame(const scoped_refptr<VideoFrame>& frame)
+  {
+    if (debug_bench_) {
+      // In bench mode just drop the frame on the floor
+      return;
+    }
+    if (red_pixel_) {
+      // Mark our frames with happy red pixels
+      uint8_t * d = frame->data(0);
+      const size_t d_stride = frame->stride(0);
+
+      for (int i = 0; i != 8; ++i, d += d_stride) {
+          for (int j = 0; j != 8 * 4; j += 4) {
+              d[j+0] = 0;
+              d[j+1] = 0;
+              d[j+2] = 0xff;
+              d[j+3] = 0xff;
+          }
+      }
+    }
+
+    output_cb_.Run(frame);
+  }
+
+protected:
+  void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    // One might have hoped that buffer->type->video.pitch[0] held this info...
+    const int stride = mmal_encoding_width_to_stride(port_->format->encoding, port_->format->es->video.width);
+    const gfx::Size cur_size = size();
+
+//    const base::TimeDelta pts(kNoTimestamp);
+
+    const base::TimeDelta pts(buffer->pts == MMAL_TIME_UNKNOWN ?
+        kNoTimestamp :
+        base::TimeDelta::FromMicroseconds(buffer->pts));
+
+#if 0
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0) {
+      LOG(ERROR) << "-- Got frame from resizer: copy_mode=" << copy_mode_ << ", len=" << buffer->length <<
+          ", size = " << port_->format->es->video.width << "x" << port_->format->es->video.height << ", req=" << cur_size.ToString() <<
+          ", stride=" << buffer->type->video.pitch[0] << "/" << stride << ", pts=" << buffer->pts <<
+          ", flags=" << std::hex << buffer->flags << std::dec << ", enabled=" << port_->is_enabled <<
+          ", pts_delta=" << (pts - last_pts_).InMicroseconds();
+        ;
+    }
+#endif
+
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS) != 0) {
+      LOG(INFO) << ">>> EOS";
+      if (fps_ != nullptr) {
+        LOG(ERROR) << "@@@@ EOS: fps=" << fps_->ToString();
+      }
+      // Finally call the decode CB
+      if (eos_pending()) {
+        eos_cb_.Run(DecodeStatus::OK);
+        eos_cb_.Reset();
+      }
+      // Remember to recycle the buffer!
+      recycle_buffer(buffer);
+      return;
+    }
+
+    if (buffer->length == 0) {
+      // Empty flushed buffer
+      recycle_buffer(buffer);
+      return;
+    }
+
+    switch (copy_mode_) {
+      case FrameCopyMode::unset:
+        LOG(ERROR) << "### copy mode unset";
+        recycle_buffer(buffer);
+        break;
+
+      case FrameCopyMode::ZERO:
+      {
+        if (debug_bench_) {
+          recycle_buffer(buffer);
+          break;
+        }
+
+        mmal_buffer_header_mem_lock(buffer);
+
+        scoped_refptr<VideoFrame> frame(new MmalZeroVideoFrame(cur_size,
+          buffer->data + buffer->type->video.offset[0],
+          stride,
+          base::Bind(&MmalVideoARGBPort::resize_cb, this),
+          base::Bind(&MmalVideoARGBPort::zc_frame_destruction_cb, this, buffer),
+          pts));
+
+        base::subtle::NoBarrier_AtomicIncrement(&zc_buffers_in_flight_, 1);
+
+        if (pts != kNoTimestamp)
+          last_pts_ = pts;
+
+        output_cb_.Run(frame);
+        break;
+      }
+
+      case FrameCopyMode::FRAME:
+      {
+        // * Arguably we should be creating ARGB buffers here rather than MMAL
+        //   but we have only carved a path through the rest of the video
+        //   render stack for MMAL
+
+#if OPT_FRAME_COPY_STASHED
+        // Firmware-side frame copy
+        scoped_refptr<VideoFrame> frame(new MmalStashedVideoFrame(
+          buffer,
+          frame_trampoline_,
+          cur_size,
+          stride,
+          pts));
+
+        if (frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+          recycle_buffer(buffer);
+        }
+#else
+        // Arm-side frame copy
+        scoped_refptr<MmalCopiedVideoFrame> frame(new MmalCopiedVideoFrame(
+          frame_trampoline_,
+          cur_size,
+          pts));
+
+        mov_frame_block(frame, buffer, stride, cur_size.width(), 0, cur_size.height());
+#endif
+
+        emit_copied_frame(frame);
+
+        if (pts != kNoTimestamp)
+          last_pts_ = pts;
+
+        break;
+      }
+
+      case FrameCopyMode::SLICE:
+      {
+        // Remember end of frame flag as we kill the buffer before using it
+        const bool eof = (buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0;
+
+        if (sliced_frame_ == NULL) {
+          sliced_y_ = 0;
+          // pts only correct at eof
+          sliced_frame_ = new MmalCopiedVideoFrame(frame_trampoline_, cur_size);
+        }
+
+        mov_frame_block(sliced_frame_, buffer, stride, cur_size.width(), sliced_y_,
+            std::min(MMAL_SLICE_HEIGHT, sliced_frame_->rows(0) - sliced_y_));
+
+        if ((sliced_y_ += MMAL_SLICE_HEIGHT) < sliced_frame_->rows(0))
+        {
+          // Partial - stop now
+          if (eof) {
+            // Partial frame - discard
+            sliced_frame_ = NULL;
+            LOG(WARNING) << "### frame underrun";
+          }
+          return;
+        }
+        if (!eof) {
+          // Overrun
+          LOG(WARNING) << "### frame overrun";
+        }
+        sliced_frame_->set_timestamp(pts);
+
+        if (pts != kNoTimestamp)
+          last_pts_ = pts;
+
+        // Make sure sliced_frame_ is NULL before we do output callbacks
+        // that might cause us to look at it
+        scoped_refptr<VideoFrame> frame(sliced_frame_.get());
+        sliced_frame_ = NULL;
+
+        emit_copied_frame(frame);
+        break;
+      }
+    }
+
+    if (fps_ != nullptr) {
+      fps_->inc_frames();
+      if (fps_->period_expired(1000000))
+      {
+        LOG(ERROR) << "--- fps = " << fps_->ToString();
+      }
+    }
+  }
+
+
+public:
+  MmalVideoARGBPort(const scoped_refptr<MmalVcInit>& vc_init, MmalComponent * const component) :
+    MmalPortAndPool(vc_init, component),
+    red_pixel_(false),
+    zc_buffers_in_flight_(0),
+    last_pts_(kNoTimestamp),
+    debug_bench_(false),
+    resize_disabled_(false)
+  {
+  }
+
+  ~MmalVideoARGBPort() override
+  {
+    kill_trampoline();
+  }
+
+  int create_frame_pool()
+  {
+    return set_pool(new MmalFramePool(vc_init_));
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+
+    port_->format->type = MMAL_ES_TYPE_VIDEO;
+  }
+
+  void set_copy_mode(const FrameCopyMode copy_mode)
+  {
+    copy_mode_ = copy_mode;
+
+    if (copy_mode_ == FrameCopyMode::SLICE) {
+      port_->format->encoding = MMAL_ENCODING_BGRA_SLICE;
+      port_->format->encoding_variant = MMAL_ENCODING_BGRA_SLICE;
+    }
+    else
+    {
+      port_->format->encoding = MMAL_ENCODING_BGRA;
+      port_->format->encoding_variant = MMAL_ENCODING_BGRA;
+    }
+  }
+
+  int set_size(const gfx::Size& req_size)
+  {
+    set_video_format(req_size, gfx::Rect(req_size), gfx::Size(), ColorSpace::COLOR_SPACE_JPEG);
+    return 0;
+  }
+
+  void set_eos_cb(const VideoDecoder::DecodeCB& eos_cb)
+  {
+    eos_cb_ = eos_cb;
+  }
+
+  int set_debug_bench(const bool enable_bench, const bool enable_fps)
+  {
+    debug_bench_ = enable_bench;
+    fps_ = std::unique_ptr<FpS>(!enable_fps ? nullptr : new FpS());
+    return 0;
+  }
+
+  int set_resize_disabled(const bool disable)
+  {
+    resize_disabled_ = disable;
+    return 0;
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    red_pixel_ = red;
+  }
+
+public:
+  int enable() override
+  {
+    if (copy_mode_ != FrameCopyMode::ZERO)
+    {
+      kill_trampoline();  // Shouldn't be needed but good to make sure
+
+      const int buffers_per_frame = copy_mode_ != FrameCopyMode::SLICE ? 1 :
+          (port_->format->es->video.crop.height + MMAL_SLICE_HEIGHT - 1) / MMAL_SLICE_HEIGHT;
+
+      frame_trampoline_ = new MmalTrampoline(buffers_per_frame * MAX_COPY_FRAMES_IN_FLIGHT,
+          base::Bind(&MmalVideoARGBPort::resize_cb, this),
+          base::Bind(&MmalVideoARGBPort::copied_frame_destruction_cb, this));
+
+      set_trampoline(frame_trampoline_);
+    }
+
+    if (MmalPortAndPool::enable() != 0)
+      return  -1;
+
+    if (fps_ != nullptr) {
+      fps_->start();
+    }
+
+    return stuff();
+  }
+
+  int enable(const VideoDecoder::OutputCB& output_cb)
+  {
+    output_cb_ = output_cb;
+    return enable();
+  }
+
+  int disable() override
+  {
+    int rv = MmalPortAndPool::disable();
+
+    // Worry about class status vars after disable to avoid race conditions
+    kill_trampoline();
+
+    sliced_frame_ = NULL;  // Forget any partial frame info
+
+    if (eos_pending()) {
+      LOG(INFO) << ">>> EOS (abort)";
+      eos_cb_.Run(DecodeStatus::ABORTED);
+      eos_cb_.Reset();
+    }
+
+//    LOG(ERROR) << "@@@@ disable: fps=" << fps.ToString();
+
+    return rv;
+  }
+
+  bool is_stalling() const
+  {
+    // If trampoline is null for some reason e.g. decoder reset
+    // then assume that in_flight is 0 as it will be when we regenerate the
+    // trampoline
+    return copy_mode_ == FrameCopyMode::ZERO ?
+      base::subtle::NoBarrier_Load(&zc_buffers_in_flight_) >= pool_size() :
+      frame_trampoline_ != nullptr && frame_trampoline_->is_stalling();
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalComponent : public base::RefCountedThreadSafe<MmalComponent>
+{
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+protected:
+  MMAL_COMPONENT_T * component_;
+private:
+  MmalTaskRunner task_runner_;
+
+protected:
+  int create_by_name(const char * const name)
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_create(name, &component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_create(" << name << ") failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  friend class base::RefCountedThreadSafe<MmalComponent>;
+  virtual ~MmalComponent()
+  {
+    if (component_ != NULL) {
+      mmal_component_release(component_);
+    }
+  }
+
+  virtual MmalConnectedPort * input_port() = 0;
+  virtual MmalConnectedPort * output_port() = 0;
+
+public:
+  MmalComponent(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    component_(NULL),
+    task_runner_(base::ThreadTaskRunnerHandle::Get())
+  {
+  }
+
+  const MmalTaskRunner& task_runner() const
+  {
+    return task_runner_;
+  }
+
+  int connect_to_output(scoped_refptr<MmalComponent> src)
+  {
+    MmalConnectedPort * const dest = input_port();
+    if (dest->connect_to_src(src->output_port()) != 0)
+      return -1;
+    if (dest->enable() != 0) {
+      dest->disconnect();
+      return -1;
+    }
+    return 0;
+  }
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_component_enable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_disable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_disable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // Shut this component down
+  // Reclaim all resources as they return & attempt to zero our internal
+  // ref count so we will die when the decoder derefs us.
+  // The reclaim process may be async so we may die some time later
+  virtual void kill() = 0;
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoDecoderComponent : public MmalComponent
+{
+  MmalVideoESPort port_in_;
+  MmalConnectedPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoDecoderComponent() override
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ ~MmalVideoDecoderComponent";
+#endif
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return NULL;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return &port_out_;
+  }
+
+
+public:
+  MmalVideoDecoderComponent(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalComponent(vc_init),
+    port_in_(vc_init, this),
+    port_out_(vc_init),
+    port_ctrl_(vc_init)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ MmalVideoDecoderComponent";
+#endif
+  }
+
+  int create(const MmalVideoDecoder::Options& opt, const VideoDecoderConfig& config, const bool low_delay)
+  {
+    if (create_by_name(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+
+    if (
+        port_ctrl_.enable() != 0 ||
+
+        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, low_delay ? -5 : -10) != 0 ||
+//        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, -3) != 0 ||
+        port_in_.config(config, low_delay) != 0 ||
+        port_in_.commit() != 0 ||
+
+//        port_out_.set_parameter(MMAL_PARAMETER_EXTRA_BUFFERS, 6) != 0 ||
+        port_out_.set_parameter(MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, false) != 0 ||
+        port_out_.set_video_encoding(opt.decoder_out_encoding()) != 0 ||
+        port_out_.set_video_format(config.coded_size(),
+            config.visible_rect(),
+            par_from_sizes(config.visible_rect().size(), config.natural_size()),
+            config.color_space()) != 0 ||
+        port_out_.commit() != 0 ||
+
+        port_in_.set_buffers(0x10000, 8) != 0 ||
+        port_in_.set_parameter(MMAL_PARAMETER_ZERO_COPY, false) != 0 ||  // ### Z-Copy is bust here
+        port_in_.create_port_pool() != 0 ||
+
+        port_in_.enable() != 0)
+    {
+      goto fail;
+    }
+
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+
+  int submit(const scoped_refptr<DecoderBuffer>& buffer, const VideoDecoder::DecodeCB& decode_cb)
+  {
+    return port_in_.submit(buffer, decode_cb);
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoResizerComponent : public MmalComponent
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size cur_size_;
+  MmalConnectedPort port_in_;
+  MmalVideoARGBPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoResizerComponent() override
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ ~MmalVideoResizerComponent";
+#endif
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return &port_in_;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return NULL;
+  }
+
+
+public:
+  MmalVideoResizerComponent(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalComponent(vc_init),
+    copy_mode_(FrameCopyMode::unset),
+    port_in_(vc_init),
+    port_out_(vc_init, this),
+    port_ctrl_(vc_init)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ MmalVideoResizerComponent";
+#endif
+  }
+
+  int create(const MmalVideoDecoder::Options& opt)
+  {
+    if (create_by_name(opt.resizer_component_name()) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+    return 0;
+  }
+
+  bool is_copy_mode_supported(const FrameCopyMode mode) const
+  {
+    return port_out_.get_parameter_supported_encodings().is_supported(mode == FrameCopyMode::SLICE ? MMAL_ENCODING_BGRA_SLICE : MMAL_ENCODING_BGRA);
+  }
+
+  int configure(const MmalVideoDecoder::Options& opt,
+      const gfx::Size& size, const VideoDecoder::OutputCB& output_cb)
+  {
+    copy_mode_ = opt.frame_copy_mode(is_copy_mode_supported(FrameCopyMode::SLICE));
+
+    port_out_.set_copy_mode(copy_mode_);
+
+    if (port_ctrl_.enable() != 0 ||
+        port_out_.set_size(opt.debug_fixed_size_set() ? opt.debug_fixed_size() : size) != 0 ||
+        port_out_.set_resize_disabled(opt.debug_fixed_size_set()) != 0 ||
+        port_out_.set_debug_bench(opt.debug_bench(), opt.debug_fps()) != 0 ||
+        port_out_.commit() != 0)
+    {
+      goto fail;
+    }
+
+    switch (copy_mode_) {
+      case FrameCopyMode::SLICE:
+        if (port_out_.set_buffers(MMAL_SLICE_HEIGHT * MMAL_LIMIT_WIDTH * 4, opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::FRAME:
+        // Firmware-side frame copy
+#if OPT_FRAME_COPY_STASHED
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, false) != 0 ||
+          port_out_.create_frame_pool() != 0)
+#else
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+#endif
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::ZERO:
+        if (port_out_.set_buffers(MMAL_LIMIT_HEIGHT * MMAL_LIMIT_WIDTH * 4, opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      default:
+        goto fail;
+    }
+
+    if (port_out_.enable(output_cb) != 0)
+      goto fail;
+
+    cur_size_ = size;
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+  void set_eos_cb(const VideoDecoder::DecodeCB& eos_cb)
+  {
+    port_out_.set_eos_cb(eos_cb);
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    port_out_.set_red_pixel(red);
+  }
+
+  bool is_output_stalling() const
+  {
+    return port_out_.is_stalling();
+  }
+};
+
+
+// ---------------------------------------------------------------------------
+
+void MmalConnection::disconnect()
+{
+  if (src_ == NULL || dest_ == NULL) {
+    LOG(ERROR) << "#### src or dest NULL";
+    return;
+  }
+
+  disable();
+
+  // Commit suicide by killing our refs
+  // Both ends should still exist as the destruction of either
+  // should call this fn
+  src_->set_connection(NULL);
+  dest_->set_connection(NULL);
+}
+
+int MmalConnection::connect(MmalConnectedPort * const src, MmalConnectedPort * const dest)
+{
+  MMAL_STATUS_T err;
+
+  // MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS means
+  // that enable will actually observe the buffer_num
+  // and size fields - otherwise it will always ignore
+  // them
+  if ((err = mmal_connection_create(&connection_, src->port_, dest->port_,
+      MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS | MMAL_CONNECTION_FLAG_TUNNELLING)) != MMAL_SUCCESS) {
+    LOG(ERROR) << "### mmal_connection_create failed: err=" << err;
+    connection_ = NULL;  // Just in case
+    return -1;
+  }
+
+  src->set_connection(this);
+  dest->set_connection(this);
+
+  src_ = src;
+  dest_ = dest;
+
+  // As we have asked for our choices to be respected we should make sure they
+  // are set to something sensible
+  set_buffers(buffer_size_recommended(), buffer_num_recommended());
+
+  mmal_log_dump_port(src->port_);
+  mmal_log_dump_port(dest->port_);
+  return 0;
+}
+
+uint32_t MmalConnection::buffer_size_recommended() const
+{
+  return std::max(src_->MmalPort::buffer_size_recommended(), dest_->MmalPort::buffer_size_recommended());
+}
+
+uint32_t MmalConnection::buffer_num_recommended() const
+{
+  return std::max(src_->MmalPort::buffer_num_recommended(), dest_->MmalPort::buffer_num_recommended());
+}
+
+uint32_t MmalConnection::buffer_size_min() const
+{
+  return std::max(src_->MmalPort::buffer_size_min(), dest_->MmalPort::buffer_size_min());
+}
+
+uint32_t MmalConnection::buffer_num_min() const
+{
+  return std::max(src_->MmalPort::buffer_num_min(), dest_->MmalPort::buffer_num_min());
+}
+
+int MmalConnection::set_buffers(uint32_t s, uint32_t n)
+{
+  src_->MmalPort::set_buffers(s, n);
+  dest_->MmalPort::set_buffers(s, n);
+  return 0;
+}
+
+
+// ---------------------------------------------------------------------------
+
+// Any refs required are applied to our enclosing object
+void MmalPortAndPool::AddRef() const
+{
+  component_->AddRef();
+}
+
+// Any refs required are applied to our enclosing object
+void MmalPortAndPool::Release()
+{
+  component_->Release();
+}
+
+const MmalTaskRunner& MmalPortAndPool::task_runner() const
+{
+  return component_->task_runner();
+}
+
+// ---------------------------------------------------------------------------
+
+// static
+bool MmalVideoDecoder::IsCodecSupported(VideoCodec codec) {
+//  LOG(ERROR) << "Test codec: " << codec;
+  // If we have checked what we can do then use that otherwise press on
+  // if we have any chance (i.e. can find a valid 4cc)
+  return (supported_video_codecs & (1 << codec)) != 0 ||
+         (supported_video_codecs == 0 && video_codec_to_fourcc(codec) != MMAL_ENCODING_UNKNOWN);
+}
+
+bool MmalVideoDecoder::IsSizeSupported(const gfx::Size& size)
+{
+  return size.width() <= MMAL_LIMIT_WIDTH &&
+    size.height() <= MMAL_LIMIT_HEIGHT &&
+    size.width() >= 32 &&
+    size.height() >= 32;
+}
+
+
+MmalVideoDecoder::MmalVideoDecoder() :
+  state_(MmalDecoderState::kNew),
+  counted_(false),
+  wants_extra_data_(false),
+  opt_(Options::Create()),
+  vc_init_(MmalVcInit::Init(opt_->single_process())),
+  weak_factory_(this)
+{
+#if TRACE_COMPONENT_CREATION
+  LOG(INFO) << "@@@ Create Decoder pid=" << getpid() << ", ppid=" << getppid();
+#endif
+
+  if (!vc_init_) {
+    state_ = MmalDecoderState::kFatal;
+    return;
+  }
+
+  opt_->set_firmware_date(vc_init_->firmware_date());
+  opt_->set_gpu_mem(vc_init_->gpu_mem());
+
+  LOG(INFO) << opt_->ToString();
+  LOG(INFO) << opt_->OptString();
+
+  state_ = MmalDecoderState::kUninitialised;
+  return;
+}
+
+MmalVideoDecoder::~MmalVideoDecoder() {
+#if TRACE_COMPONENT_CREATION
+  LOG(INFO) << "@@@ Destroy Decoder";
+#endif
+
+  uninitialise();
+
+  if (counted_) {
+    base::subtle::NoBarrier_AtomicIncrement(&decoder_count, -1);
+  }
+}
+
+
+
+std::string MmalVideoDecoder::GetDisplayName() const {
+  return "MmalVideoDecoder";
+}
+
+
+void MmalVideoDecoder::uninitialise(const MmalDecoderState new_state)
+{
+  if (decoder_ != NULL) {
+    decoder_->kill();
+    decoder_ = NULL;
+  }
+  if (resizer_ != NULL) {
+    resizer_->kill();
+    resizer_ = NULL;
+  }
+
+  extra_data_ = NULL;
+  wants_extra_data_ = false;
+
+  state_ = new_state;
+}
+
+// EOS callback - accessed via WeakPtr so if we are destroyed
+// whilst EOS is still pending this won't happen
+//
+// We call Reset on EOS.  This has a couple of benefits
+// 1) It reclaims memory as soon as possible (there's a decent chance we
+//    are done with this decoder now)
+// 2) It should allow us to go <decode> <eos> <decode> which is defined to
+//    work in the Decode spec (even if it doesn't seem to happen in reality)
+
+void MmalVideoDecoder::eos_cb(const DecodeCB decode_cb, DecodeStatus status)
+{
+//  LOG(ERROR) << "+++ EOS(" << status << ")";
+  Reset(base::Bind(decode_cb, status));
+}
+
+// Initializes a VideoDecoder with the given |config|, executing the
+// |init_cb| upon completion. |output_cb| is called for each output frame
+// decoded by Decode().
+//
+// If |low_delay| is true then the decoder is not allowed to queue frames,
+// except for out-of-order frames, i.e. if the next frame can be returned it
+// must be returned without waiting for Decode() to be called again.
+// Initialization should fail if |low_delay| is true and the decoder cannot
+// satisfy the requirements above.
+//
+// |cdm_context| can be used to handle encrypted buffers. May be null if the
+// stream is not encrypted.
+//
+// Note:
+// 1) The VideoDecoder will be reinitialized if it was initialized before.
+//    Upon reinitialization, all internal buffered frames will be dropped.
+// 2) This method should not be called during pending decode or reset.
+// 3) No VideoDecoder calls should be made before |init_cb| is executed.
+// 4) VideoDecoders should take care to run |output_cb| as soon as the frame
+// is ready (i.e. w/o thread trampolining) since it can strongly affect frame
+// delivery times with high-frame-rate material.  See Decode() for additional
+// notes.
+
+void MmalVideoDecoder::Initialize(const VideoDecoderConfig& config,
+                                    bool low_delay,
+                                    CdmContext* /* cdm_context */,
+                                    const InitCB& init_cb,
+                                    const OutputCB& output_cb) {
+  LOG(INFO) << "Mmal Init: low_delay=" << low_delay << ", config=" << config.AsHumanReadableString();
+
+  DCHECK(config.IsValidConfig());
+  DCHECK(!output_cb.is_null());
+
+  InitCB bound_init_cb = BindToCurrentLoop(init_cb);
+
+  // If dead - give up now
+  if (state_ <= MmalDecoderState::kFatal) {
+    LOG(ERROR) << __func__ << ": FATAL";
+    bound_init_cb.Run(false);
+    return;
+  }
+
+  // If already inited (or failed) then kill
+  if (state_ != kUninitialised) {
+    // * This is unsubtle in the extreme
+    // and we would really prefer to wait for the kill ops to finish
+    // before continuing so we don't have an overlap where we have
+    // two sets of resizer buffers ... or preserve the resizer...
+    // or something...
+    uninitialise();
+  }
+
+  if (state_ != kUninitialised) {
+    LOG(ERROR) << __func__ << ": Unexpected state: " << state_;
+    goto fail;
+  }
+
+  // Do we support this?
+  if (config.is_encrypted() || !IsCodecSupported(config.codec()) ||
+      !IsSizeSupported(config.coded_size())) {
+//    LOG(ERROR) << "Encrypted or unsupported";
+    // No
+    goto fail;
+  }
+
+  // Check count
+  // 0 will effectively turn off mmal decode
+  if (!counted_)
+  {
+    const int n = (int)base::subtle::NoBarrier_AtomicIncrement(&decoder_count, 1);
+    const int max_dec = (int)opt_->max_decoders();
+    counted_ = true;
+    if (n > max_dec) {
+      LOG(WARNING) << __func__ << ": Exceeded decoder limit: " << n << "/" << max_dec;
+      goto fail;
+    }
+  }
+
+  LOG(INFO) << "Decoder count:" << decoder_count << "/" << opt_->max_decoders();
+
+  // Stash for later reset
+  decoder_config_ = config;
+  low_delay_ = opt_->low_delay(low_delay);
+
+  if (config.extra_data().size() != 0)
+  {
+    extra_data_ = DecoderBuffer::CopyFrom(&config.extra_data()[0], config.extra_data().size());
+    wants_extra_data_ = true;
+  }
+
+  decoder_ = new MmalVideoDecoderComponent(vc_init_);
+  if (decoder_->create(*opt_, config, low_delay_) != 0)
+    goto fail;
+  if (decoder_->enable() != 0)
+    goto fail;
+
+  resizer_ = new MmalVideoResizerComponent(vc_init_);
+
+  if (resizer_->create(*opt_) != 0)
+    goto fail;
+
+  if (resizer_->configure(*opt_,
+      config.natural_size(),
+      BindToCurrentLoop(output_cb)) != 0)
+    goto fail;
+
+  resizer_->set_red_pixel(opt_->red_pixel());
+  if (resizer_->enable() != 0)
+    goto fail;
+
+  if (resizer_->connect_to_output(decoder_) != 0)
+    goto fail;
+
+  state_ = MmalDecoderState::kInitialised;
+
+  // Success!
+  bound_init_cb.Run(true);
+  return;
+
+
+fail:
+  LOG(INFO) << __func__ << ": FAILED";
+  uninitialise(std::min(state_, MmalDecoderState::kFail));
+  if (counted_) {
+    counted_ = false;
+    base::subtle::NoBarrier_AtomicIncrement(&decoder_count, -1);
+  }
+  bound_init_cb.Run(false);
+}
+
+// Requests a |buffer| to be decoded. The status of the decoder and decoded
+// frame are returned via the provided callback. Some decoders may allow
+// decoding multiple buffers in parallel. Callers should call
+// GetMaxDecodeRequests() to get number of buffers that may be decoded in
+// parallel.
+//
+// Implementations guarantee that the |decode_cb| will not be called from
+// within this method, and that it will be called even if Decode() is never
+// called again.
+//
+// After decoding is finished the decoder calls |output_cb| specified in
+// Initialize() for each decoded frame. |output_cb| may be called before or
+// after |decode_cb|, including before Decode() returns.
+//
+// If |buffer| is an EOS buffer then the decoder must be flushed, i.e.
+// |output_cb| must be called for each frame pending in the queue and
+// |decode_cb| must be called after that. Callers will not call Decode()
+// again until after the flush completes.
+void MmalVideoDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
+                                const DecodeCB& decode_cb) {
+  DCHECK(buffer.get());
+  DCHECK(!decode_cb.is_null());
+
+  CHECK(decoder_ == nullptr || decoder_->task_runner()->BelongsToCurrentThread());
+
+  const bool eos_req = buffer->end_of_stream();
+
+//  LOG(ERROR) << "<<< Decode: state=" << state_ << ", buffer=" << buffer->AsHumanReadableString();
+  DecodeCB decode_cb_bound(BindToCurrentLoop(decode_cb));
+
+  // If we are in any state except running (reset, never sent data, eos)
+  // then EOS won't propagate and we should ack here & now
+  if (eos_req && state_ != MmalDecoderState::kRunning) {
+    LOG(INFO) << "<<< >>> EOS";
+    decode_cb_bound.Run(DecodeStatus::OK);
+    return;
+  }
+
+  if (state_ == MmalDecoderState::kResetEOS) {
+    // * Really we should be able to do half this work
+    //   and drop into ResetRun but the enables don't currently work
+    //   correctly for that
+
+    decoder_ = new MmalVideoDecoderComponent(vc_init_);
+    if (decoder_->create(*opt_, decoder_config_, low_delay_) != 0)
+      goto fail;
+    if (decoder_->enable() != 0)
+      goto fail;
+
+    if (resizer_->connect_to_output(decoder_) != 0)
+      goto fail;
+
+    resizer_->reset2();
+
+    wants_extra_data_ = (extra_data_ != NULL);
+
+    state_ = MmalDecoderState::kInitialised;
+  }
+  else if (state_ == MmalDecoderState::kResetRun) {
+    resizer_->reset2();
+    decoder_->reset2();
+    wants_extra_data_ = (extra_data_ != NULL);
+    state_ = MmalDecoderState::kInitialised;
+  }
+
+  if (state_ < MmalDecoderState::kInitialised)
+  {
+    LOG(ERROR) << "### Decode in bad state: " << state_;
+    goto fail;
+  }
+
+  if (wants_extra_data_) {
+    if (extra_data_ == NULL) {
+      LOG(ERROR) << "### extra_data_ NULL";
+      goto fail;
+    }
+
+    wants_extra_data_ = false;
+    if (decoder_->submit(extra_data_, DecodeCB()) < 0)
+      goto fail;
+  }
+
+  if (eos_req) {
+    // eos_cb must be called on the current thread
+    resizer_->set_eos_cb(BindToCurrentLoop(
+        base::Bind(&MmalVideoDecoder::eos_cb, weak_factory_.GetWeakPtr(), decode_cb)));
+
+    // The decode_cb we pass here isn't ever used - it just indicates that
+    // we want Qed submission.  * Mucky.
+    if (decoder_->submit(buffer, decode_cb_bound) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kEOS;
+  }
+  else
+  {
+    if (decoder_->submit(buffer, decode_cb_bound) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kRunning;
+  }
+
+//  LOG(ERROR) << ">>> Decode";
+  return;
+
+fail:
+  LOG(WARNING) << ">>> Decode: FAIL";
+  decode_cb_bound.Run(DecodeStatus::DECODE_ERROR);
+}
+
+// Resets decoder state. All pending Decode() requests will be finished or
+// aborted before |closure| is called.
+// Note: No VideoDecoder calls should be made before |closure| is executed.
+//
+// This fn shuts stuff down - restart is managed at the beginning of Decode
+
+void MmalVideoDecoder::Reset(const base::Closure& closure) {
+  switch (state_) {
+    case MmalDecoderState::kRunning:
+      LOG(INFO) << "--- Reset (running)";
+      decoder_->reset1();
+      resizer_->reset1();
+      state_ = MmalDecoderState::kResetRun;
+      break;
+
+    case MmalDecoderState::kEOS:
+      LOG(INFO) << "--- Reset (EOS)";
+      decoder_->kill();
+      decoder_ = NULL;
+      resizer_->reset1();
+      state_ = MmalDecoderState::kResetEOS;
+      break;
+
+    default:
+      LOG(INFO) << "--- Reset (null)";
+      break;
+  }
+
+  // Ensure the closure is scheduled after any callbacks triggered by
+  // the reset sequence
+  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, closure);
+  return;
+}
+
+bool MmalVideoDecoder::CanReadWithoutStalling() const
+{
+  return resizer_ == nullptr || !resizer_->is_output_stalling();
+}
+
+int MmalVideoDecoder::GetMaxDecodeRequests() const
+{
+  return 1;
+}
+
+}  // namespace media
+
+
Index: chromium-browser-65.0.3325.181/media/filters/mmal_video_decoder.h
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/media/filters/mmal_video_decoder.h
@@ -0,0 +1,162 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+#define MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
+#include <list>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "media/base/video_decoder.h"
+#include "media/base/video_decoder_config.h"
+#include "media/base/video_frame_pool.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+
+struct AVCodecContext;
+struct AVFrame;
+
+namespace base {
+class SingleThreadTaskRunner;
+}
+
+namespace media {
+
+class DecoderBuffer;
+class MmalVideoDecoderComponent;
+class MmalVideoResizerComponent;
+class MmalVcInit;
+
+class MEDIA_EXPORT MmalVideoDecoder : public VideoDecoder {
+public:
+  class Options;
+
+private:
+  enum MmalDecoderState {
+      kFatal = -2,
+      kFail = -1,
+      kNew = 0,
+      kUninitialised,
+      kReseting,
+      kResetEOS,     // Reset from EOS
+      kResetRun,     // Reset from running
+      kInitialised,  // Init but no decode yet
+      kRunning,      // Have successful decode
+      kEOS           // EOS rxed
+  };
+
+  MmalDecoderState state_;
+
+  // Have we counted this decoder (for decoder count limits) yet?
+  bool counted_;
+
+  scoped_refptr<DecoderBuffer> extra_data_;
+  bool wants_extra_data_;
+
+  scoped_refptr<MmalVideoDecoderComponent> decoder_;
+  // Resizer may persist after VideoDecoder dies if it maintains frames
+  // with shared VC memory
+  scoped_refptr<MmalVideoResizerComponent> resizer_;
+
+  VideoDecoderConfig decoder_config_;
+  bool low_delay_;
+
+  const std::unique_ptr<Options> opt_;
+  scoped_refptr<MmalVcInit> vc_init_;
+
+  void uninitialise(const MmalDecoderState new_state = kUninitialised);
+  void eos_cb(const DecodeCB decode_cb, DecodeStatus status);
+
+ public:
+  static bool IsCodecSupported(VideoCodec codec);
+  static bool IsSizeSupported(const gfx::Size& size);
+
+  MmalVideoDecoder();
+  ~MmalVideoDecoder() override;
+
+  // VideoDecoder implementation.
+  std::string GetDisplayName() const override;
+
+  void Initialize(const VideoDecoderConfig& config,
+                  bool low_delay,
+                  CdmContext* cdm_context,
+                  const InitCB& init_cb,
+                  const OutputCB& output_cb) override;
+  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
+              const DecodeCB& decode_cb) override;
+  void Reset(const base::Closure& closure) override;
+  bool CanReadWithoutStalling() const override;
+  int GetMaxDecodeRequests() const override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MmalVideoDecoder);
+  base::WeakPtrFactory<MmalVideoDecoder> weak_factory_;
+};
+
+class MmalVideoFrame : public VideoFrame
+{
+protected:
+  gpu::Mailbox id_;
+  base::Closure kill_id_;
+//  int shmid_;
+
+  ~MmalVideoFrame() override;
+public:
+  MmalVideoFrame(
+      const StorageType storage_type,
+      const gfx::Size& coded_size,
+      const gfx::Rect& visible_rect,
+      const gfx::Size& natural_size,
+      const base::TimeDelta timestamp,
+      const gpu::Mailbox& id = gpu::Mailbox());
+
+  static scoped_refptr<MmalVideoFrame> Coerce(const scoped_refptr<VideoFrame>& frame)
+  {
+    if (frame->format() != PIXEL_FORMAT_MMAL_BUFFER) {
+      NOTREACHED();
+      return scoped_refptr<MmalVideoFrame>();
+    }
+    return scoped_refptr<MmalVideoFrame>(static_cast<MmalVideoFrame *>(frame.get()));
+  }
+
+  gpu::Mailbox get_id() const
+  {
+    return id_;
+  }
+
+//  int get_shmid() const
+//  {
+//    return shmid_;
+//  }
+
+  static inline uint32_t hashid(const gpu::Mailbox& id)
+  {
+    uint32_t x = 0;
+    for (uint32_t c : id.name) {
+      x = x * 67 + c;
+    }
+    return x;
+  }
+
+  uint32_t hashid() const
+  {
+    return hashid(id_);
+  }
+
+  void set_id_and_kill(const gpu::Mailbox& id, const base::Closure& kill)
+  {
+    kill_id_ = kill;
+    id_ = id;
+  }
+};
+
+
+}  // namespace media
+
+#endif  // MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
+
Index: chromium-browser-65.0.3325.181/media/remoting/proto_enum_utils.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/remoting/proto_enum_utils.cc
+++ chromium-browser-65.0.3325.181/media/remoting/proto_enum_utils.cc
@@ -352,7 +352,8 @@ base::Optional<VideoPixelFormat> ToMedia
     // PIXEL_FORMAT_Y8 is deprecated .
     case pb::VideoDecoderConfig_Format_PIXEL_FORMAT_Y8:
       return base::nullopt;
-   CASE_RETURN_OTHER(PIXEL_FORMAT_Y16);
+    CASE_RETURN_OTHER(PIXEL_FORMAT_Y16);
+    CASE_RETURN_OTHER(PIXEL_FORMAT_MMAL_BUFFER);
   }
   return base::nullopt;  // Not a 'default' to ensure compile-time checks.
 }
@@ -388,6 +389,7 @@ base::Optional<pb::VideoDecoderConfig::F
     CASE_RETURN_OTHER(PIXEL_FORMAT_YUV422P12);
     CASE_RETURN_OTHER(PIXEL_FORMAT_YUV444P12);
     CASE_RETURN_OTHER(PIXEL_FORMAT_Y16);
+    CASE_RETURN_OTHER(PIXEL_FORMAT_MMAL_BUFFER);
   }
   return base::nullopt;  // Not a 'default' to ensure compile-time checks.
 }
Index: chromium-browser-65.0.3325.181/media/remoting/rpc.proto
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/remoting/rpc.proto
+++ chromium-browser-65.0.3325.181/media/remoting/rpc.proto
@@ -216,6 +216,7 @@ message VideoDecoderConfig {
     PIXEL_FORMAT_YUV444P12 = 24;
     PIXEL_FORMAT_Y8 = 25 [deprecated = true];
     PIXEL_FORMAT_Y16 = 26;
+    PIXEL_FORMAT_MMAL_BUFFER = 27;
   };
 
   // Proto version of media::ColorSpace.
Index: chromium-browser-65.0.3325.181/media/renderers/default_renderer_factory.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/renderers/default_renderer_factory.cc
+++ chromium-browser-65.0.3325.181/media/renderers/default_renderer_factory.cc
@@ -17,6 +17,7 @@
 #include "media/base/media_switches.h"
 #include "media/filters/gpu_video_decoder.h"
 #include "media/media_features.h"
+#include "media/filters/mmal_video_decoder.h"
 #include "media/renderers/audio_renderer_impl.h"
 #include "media/renderers/renderer_impl.h"
 #include "media/renderers/video_renderer_impl.h"
@@ -104,6 +105,10 @@ DefaultRendererFactory::CreateVideoDecod
     }
   }
 
+#ifdef __ARM_ARCH
+  video_decoders.push_back(std::make_unique<MmalVideoDecoder>());
+#endif
+
 #if BUILDFLAG(ENABLE_LIBVPX)
   video_decoders.push_back(std::make_unique<OffloadingVpxVideoDecoder>());
 #endif
Index: chromium-browser-65.0.3325.181/media/renderers/paint_canvas_video_renderer.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/renderers/paint_canvas_video_renderer.cc
+++ chromium-browser-65.0.3325.181/media/renderers/paint_canvas_video_renderer.cc
@@ -22,6 +22,7 @@
 #include "skia/ext/texture_handle.h"
 #include "third_party/libyuv/include/libyuv.h"
 #include "third_party/skia/include/core/SkImage.h"
+#include "third_party/skia/src/core/SkImagePriv.h"
 #include "third_party/skia/include/core/SkImageGenerator.h"
 #include "third_party/skia/include/gpu/GrBackendSurface.h"
 #include "third_party/skia/include/gpu/GrContext.h"
@@ -384,6 +385,7 @@ void PaintCanvasVideoRenderer::Paint(
   // frame has an unexpected format.
   if (!video_frame.get() || video_frame->natural_size().IsEmpty() ||
       !(media::IsYuvPlanar(video_frame->format()) ||
+        video_frame->format() == PIXEL_FORMAT_MMAL_BUFFER ||
         video_frame->format() == media::PIXEL_FORMAT_Y16 ||
         video_frame->HasTextures())) {
     cc::PaintFlags black_with_alpha_flags;
@@ -809,6 +811,7 @@ void PaintCanvasVideoRenderer::ConvertVi
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_MJPEG:
     case PIXEL_FORMAT_MT21:
+    case PIXEL_FORMAT_MMAL_BUFFER:
     case PIXEL_FORMAT_UNKNOWN:
       NOTREACHED() << "Only YUV formats and Y16 are supported, got: "
                    << media::VideoPixelFormatToString(video_frame->format());
@@ -1051,6 +1054,18 @@ bool PaintCanvasVideoRenderer::UpdateLas
         paint_image_builder.set_image(
             NewSkImageFromVideoFrameNative(video_frame.get(), context_3d));
       }
+    } else if (video_frame->format() == PIXEL_FORMAT_MMAL_BUFFER) {
+      // If we have a mmal buffer generate an image from it directly
+      // (or as close to directly as we can manage)
+      SkBitmap skbitmap;
+      const SkImageInfo info(SkImageInfo::MakeN32(video_frame->visible_rect().width(),
+        video_frame->visible_rect().height(), kOpaque_SkAlphaType));
+
+      // ?? No release function on the bitmap
+      skbitmap.installPixels(info, video_frame->data(0), video_frame->stride(0));
+
+      paint_image_builder.set_image(SkMakeImageFromRasterBitmap(skbitmap, kNever_SkCopyPixelsMode));
+
     } else {
       paint_image_builder.set_paint_image_generator(
           sk_make_sp<VideoImageGenerator>(video_frame));
Index: chromium-browser-65.0.3325.181/media/video/gpu_memory_buffer_video_frame_pool.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ chromium-browser-65.0.3325.181/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -470,6 +470,7 @@ void GpuMemoryBufferVideoFramePool::Pool
     case PIXEL_FORMAT_YUV422P12:
     case PIXEL_FORMAT_YUV444P12:
     case PIXEL_FORMAT_Y16:
+    case PIXEL_FORMAT_MMAL_BUFFER:
     case PIXEL_FORMAT_UNKNOWN:
       frame_ready_cb.Run(video_frame);
       return;
Index: chromium-browser-65.0.3325.181/net/disk_cache/simple/simple_index_file_posix.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/net/disk_cache/simple/simple_index_file_posix.cc
+++ chromium-browser-65.0.3325.181/net/disk_cache/simple/simple_index_file_posix.cc
@@ -16,6 +16,8 @@
 #include "base/files/file_util.h"
 #include "base/logging.h"
 
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+
 namespace disk_cache {
 namespace {
 
Index: chromium-browser-65.0.3325.181/pi-util/BUILD.txt
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/BUILD.txt
@@ -0,0 +1,220 @@
+Build notes (cross compile from Ubuntu)
+=======================================
+
+Build from a patch
+------------------
+
+# Pick somewhere to put this
+cd ~
+mkdir chromium
+cd chromium
+# Get the build tools & put on path
+# You may want to add the path in .bashrc
+git clone https://chromium.googlesource.com/chromium/tools/depot_tools
+export PATH=$PATH:`pwd`/depot_tools
+# Get the main tree
+fetch chromium
+cd src
+# Checkout the version you want
+# * Fix version number
+git checkout 55.0.2883.99
+# Fix up any missing dependancies on the build m/c
+# * may well be unnecessary if you have built any other chrome
+./build/install-build-deps.sh
+./build/install-build-deps.sh --arm
+# Fetch & pull the other bits of the tree to sync.
+# As we are checking out a tag the --with_branch_heads is important
+gclient sync --with_branch_heads
+# Patch - should be completely clean if everything matchs
+# * Fix patch file to correct name / location
+cd ..
+patch -p1 < v55.0.2883.99.patch
+cd src
+# * Get a sysroot from somewhere and put it in build/linux/raspian_jessie_pi1-sysroot
+# * Example below is only if you have got an appropriate one lying around
+# * Otherwise follow sysroot instructions further down
+rsync -rl previous_location/raspian_jessie_pi1-sysroot build/linux/
+# Build output directories (out/armv6, out/armv7)
+# * This script currently assumes a sysroot of build/linux/raspian_jessie_pi1-sysroot
+#   so may need editing if you have put it elsewhere
+pi-util/gngen.py
+# Build chrome
+ninja -C out/armv6 chrome chrome_sandbox
+# Build armv7 ffmpeg
+ninja -C out/armv7 third_party/ffmpeg
+
+
+To run on a Pi
+--------------
+
+This requires a little installation.  The sandbox and ffmpeg shared libs
+need to be copied to the pi.  As neither is being tweaked much by me these
+steps should only be required if the underlying Chrome changes.  Otherwise
+you can just run out of the build directory (src/out/armv6)
+
+Assuming you can mount the build dir from the pi.
+
+# On the Pi NOT the build machine
+cd <path to build env>/src
+# Copy the ffmpeg libs
+pi-util/cplibs.sh
+# Copy the sandbox. BUILDTYPE tells the script where to get it from
+# This doesn't seem to be needed anymore with linux 4.9 and chrome 55
+BUILDTYPE=armv6 build/update-linux-sandbox.sh
+# Run chrome
+cd out/armv6
+./chrome
+
+
+Rebuilds
+--------
+
+In most cases a simple "ninja -C out/armv6 chrome" is all that is needed
+and the pi can run from out/armv6.
+
+To clean build "rm -rf out" and follow the build instructions from gngen.py
+
+
+Updating chromium from git
+--------------------------
+
+There is no script for this as the merges are prone to conflicts and it
+is much easier to sort them if you are doing stuff manually.
+
+If updating between major versions then mergeing tends to fail horribly
+so something along the lines of:
+
+# * Make sure there are no updates required and no untracked files
+pi-util/gitscan.py status
+# Tag source & make a patch file - patch file is useful when files are moved
+# as then git goes all unhelpful
+pi-util/settag.py -p mmal_2.13
+# As git stash will reset the brnch switch to a temp branch 1st
+pi-util/gitscan.py checkout -b stash/61/base
+pi-util/gitscan.py --gitscan-no-src reset {BASE}
+pi-util/gitscan.py --gitscan-no-src stash -u
+pi-util/gitscan.py --gitscan-no-src checkout {BASE}
+
+# Need to do src separately as the stash will lose pi-utils
+cat pi-util/pipaths.py
+git reset 56.0.2924.84
+git stash -u
+
+git checkout <new tag>
+
+# Clean out old objects
+rm -rf obj
+# Beware that git clean might kill our sub-repos so so don't do it unless we
+# are sure it won't
+# git clean -dxf
+
+### Do the "get environment" stages of a new build
+...
+
+# Start rebuild
+git stash pop
+### Fix conflicts (there will be some)
+
+# Fix version tag in pi-util/pipaths.py
+# Fix chrome major version for ffmpeg .so in pi-util/cplibs.sh and third_party//ffmpeg/BUILD.gn
+
+git commit
+### run through all other dirs we care about doing the same
+### Probably need to fix exec perms on pi-util scripts
+pi-util/gngen.py
+### Fix up any new libpackage-dev that we need
+ninja ...
+### Fix up build disasters
+
+
+If updating within a major version mergeing seems to work reliably so my
+preferred method for achieving this goes:
+
+# Make sure everything is committed
+pi-util/gitscan.py status
+# Revert to base chromium checkout for old checkout
+pi-util/gitscan.py --gitscan-no-src checkout {BASE}
+# Merge new version into current base
+git fetch --all
+TAG=<new_tag>
+git merge $TAG
+# Fix conflicts - DEPS always seems to conflict
+git checkout $TAG -- DEPS
+# Update pi-util/pipaths.py to contain the new tag
+# Either commit now or later
+sed "s/src_commit=.*/src_commit=\"$TAG\"/" pi-util/pipaths.py | tee t
+mv t pi-util/pipaths.py && git add pi-util/pipaths.py
+git commit --no-edit
+# Get the rest of the tree
+gclient sync --with_branch_heads
+# Checkout our tree and merge the new base into it
+pi-util/gitscan.py --gitscan-no-src checkout test/65/mmal_2
+pi-util/gitscan.py --gitscan-no-src merge --no-edit {BASE}
+
+and we should be good to go.  At this point you can either clean build or
+not.  Chromes dependancy checks seem remarkably good so a simple build
+works nearly all the time.
+
+# Rebuild gn (clean)
+rm -rf out
+pi-util/gngen.py
+# Build armv7 ffmpeg
+ninja -C out/armv7 third_party/ffmpeg
+# Build chrome
+LD_LIBRARY_PATH=`pwd`/out/armv6/clang_x86_v8_arm ninja -C out/armv6 chrome chrome_sandbox
+
+
+Sysroots (one time only)
+------------------------
+
+1st you will need to get the dev files for a bunch of libs on your pi (or
+if you can get the right files by magic on your cross-compile m/c then
+that is good too).  In src/pi-util there is a shell script
+pi-install-dev.sh which lists all the libs I think are needed along with a
+helpful apt-get install so all you should need to do is run it on an
+appropriate pi.
+
+Next the appropriate bits need to be copied to
+build/linux/<sysroot-name>-sysroot. We use raspian_stretch_pi1 as the
+sysroot name in these instructions and in the example script files so you
+might well find it easiest to use the same name too
+
+The script pi-util/syncroot.sh that will copy the needed bits of a root to
+the right place and then fix the full path symlinks to be relative.  It
+uses rsync to copy the files so the src can contain a machine name
+
+pi-util/syncroot.sh my-pi: raspian_stretch_pi1
+
+The "raspian_stretch_pi1" can be omitted and syncroot will choose the current
+default sysroot name.
+
+Beware that there are ~8 rsync statements so if the rsync is operating
+over ssh then you may need to type your password 8 times...  Note also
+that the script appends -sysroot to the given name so don't add that
+yourself!
+
+If the pi root is updated then this script can / should be rerun to update
+the sysroot.
+
+
+
+Other notes on the tree
+-----------------------
+
+The definitive list of expected repos is in pi-util/pipaths.py
+
+The script pi-util/gitscan.py will perform the same git op on all the
+repos that are in use in the current patch set.  It has substitutions
+of {PATH} and {BASE} for the path to the current repo and the chromium
+commit on which the current branch is based
+
+The current dev branch is test/57/mmal_2
+
+Status of optional neon by build file:
+skia/BUILD.gn:                     yes
+build/secondary/third_party/libjpeg_turbo/BUILD.gn: yes
+third_party/libwebp/BUILD.gn:      yes
+third_party/openmax_dl/dl/BUILD.gn unused
+third_party/libyuv/BUILD.gn:       yes
+third_party/libyuv/libyuv.gni:     yes
+third_party/pdfium/skia/BUILD.gn:  unused
Index: chromium-browser-65.0.3325.181/pi-util/README.txt
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/README.txt
@@ -0,0 +1,100 @@
+Release notes
+=============
+
+This version should run with gpu-mem=64 with the default switches. Having
+said that this will only allow for 1 stream.  If you are playing >1 stream
+(even transiently) then you will need more (say gpu_mem=128) and you will
+need to set the --mmal-decoders option to the desired max number. The code
+should give up cleanly if it cannot allocate a h/w video decoder and give
+the stream to old-style ffmpeg decode, but as it stands in many cases it
+thinks it has allocated a decoder cleanly only to find that it fails when
+it tries to use it.
+
+Needs firmware from "Sep 13 2016 17:01:56" or later to work properly
+("vcgencmd version" will give the date).
+
+There are a few command-line switches - in general you shouldn't use
+them!
+
+
+Decode and resizer options
+--------------------------
+
+--mmal-decode-opaque     Set the decoder to use opaque frames between
+decoder and resizer.  This should be faster than i420 but doesn't work
+with old firmware.  This is the default with newer firmware (>=
+2016-11-01). (see --mmal-decode-i420)
+
+--mmal-decode-i420       Set the decoder to use I420 frames between
+decoder and resizer.  This generates an unnecessary conversion but works
+with all firmware.  This is the default with older firmware (<
+2016-11-01). (see --mmal-decode-opaque)
+
+--mmal-low-delay         Force "low-delay" mode on the decoder pipe.  This
+reduces the number of buffered ES frames before the decoder.  It isn't
+exactly low-delay but is definitely lower than otherwise.  May have a
+slight performance penalty and increase the risk of stuttering.  This mode
+will be automatically set by Chrome for some streams.
+
+--mmal-resize-isp        Use ISP resize rather than resizer.  Is noticably
+faster but requires --mmal-frame-copy or --mmal-zero-copy and newer
+firmware.  This is the default with newer firmware  (>= 2016-11-01) and
+enough gpu memory to support --mmal-frame-copy.
+
+--mmal-resize-resizer    Use resizer rather than ISP. Slower than ISP
+resize but supports older firmware and --mmal-slice-copy which may be
+needed if GPU memory is very limited (as will be the case on a Pi1 with a
+default setup).
+
+Copy-modes
+----------
+
+These are modes for getting frames out of mmal.  Current default is
+--mmal-frame-copy if --mmal-resize-isp is the default resizer or it looks
+like the firmware doesn't support --mmal-slice-copy otherwise
+--mmal-slice-copy is the default. Explicit use of a copy mode option will
+override the default regardless of whether or not we think the firmware
+supports the selected option.  Only use one of of these flags.
+
+--mmal-zero-copy         Pass gpu frames directly to chrome.  Chrome
+buffers some frames and stalls if it doesn't get them. So this option
+needs 6+ gpu frames allocated.  This is now a legacy and testing option as
+--mmal-frame-copy is faster and you probably want to have gpu_mem=192 if
+you are going to use it. Default frame-buffers = 6 (8M each)
+
+--mmal-frame-copy        Copy frame at a time out of mmal to chrome.
+Currently the fastest option.  Needs 2+ gpu frames for plausible
+performance. Default frame-buffers = 2 (8M each).  You probably want
+gpu-mem=80 for 1 decoder with this option.
+
+--mmal-slice-copy        Copy frames out in 16-line slices.  Has the
+lowest memory overhead, but the highest CPU load.  If this is selected
+then --mmal-frame-buffers is the number of slice buffers. Default frame
+buffers = 16 (~122k each).
+
+Misc options
+------------
+
+--enable-logging=stderr This is a standard option for chrome but worth
+noting as the mmal code will print out its interpretation of the command
+line options passed to it along with how much GPU memory it has detected
+and the firmware date.
+
+--pi-patch-version       Print out the versions of Chromium and Pi
+patches.  Chrome will then terminate
+
+--mmal-decoders=<n>      Set the number of mmal decoders we wil try to
+create simultainiously. Default=1. If this number is exceeded then decoder
+init will fail and chrome will fallback to ffmpeg decode.  There is no
+panalty for setting this to a large number if you wish to have "unlimited"
+decoders.  However if it is set too big and there isn't the gpu mem to
+satisfy the requirements of the decode it may fail cleanly and revert to
+software (ffmpeg) decode or init may appear to succeed and decode then
+fails in an undefined manner.
+
+--mmal-frame-buffers=<n> Set the number of gpu "frame" buffers (see
+--mmal-xxx-copy). Change with care.
+
+--mmal-red-pixel         Puts a red square in the top left of a frame
+decoded by mmal so you can tell that it is active.  Doesn't work if
+zero-copy is set.
Index: chromium-browser-65.0.3325.181/pi-util/cplibs.sh
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/cplibs.sh
@@ -0,0 +1,19 @@
+set -e
+
+FFNAME=libffmpeg_chrome.so.65
+LIBROOT=/usr/lib/arm-linux-gnueabihf
+
+if [ ! -d $LIBROOT ]; then
+  echo Can\'t find $LIBROOT
+  echo Are you sure you are running this on a Pi?
+  exit 1
+fi
+
+echo Copying $FFNAME from armv6/7 to $LIBROOT/...
+
+cp out/armv7/$FFNAME /tmp
+sudo cp /tmp/$FFNAME $LIBROOT/neon/vfp
+cp out/armv6/$FFNAME /tmp
+sudo cp /tmp/$FFNAME $LIBROOT
+
+
Index: chromium-browser-65.0.3325.181/pi-util/defargs_armv6.gn
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/defargs_armv6.gn
@@ -0,0 +1,28 @@
+# See "gn args <out_dir> --list" for available build arguments.
+is_debug = false
+target_cpu = "arm"
+target_os = "linux"
+
+arm_float_abi = "hard"
+arm_use_neon = false
+arm_optionally_use_neon = true
+arm_version = 6
+arm_use_thumb = false
+arm_arch = "armv6z"
+
+# Separate out so we can have both arm v6 & v7 versions
+is_component_ffmpeg = true
+
+# tcmalloc doesn't like armv6 by default
+use_allocator = "none"
+
+# Pulse deprecated on Pi
+use_pulseaudio = false
+
+# Could use system libjpeg but go with chromiums version
+# use_system_libjpeg = true
+use_libjpeg_turbo = true
+
+# We want H.264 in ffmpeg
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
Index: chromium-browser-65.0.3325.181/pi-util/defargs_armv7.gn
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/defargs_armv7.gn
@@ -0,0 +1,22 @@
+# Build arguments go here. Examples:
+#   is_component_build = true
+#   is_debug = false
+# See "gn args <out_dir> --list" for available build arguments.
+is_debug = false
+target_cpu = "arm"
+target_os = "linux"
+
+arm_float_abi = "hard"
+arm_use_neon = true
+arm_optionally_use_neon = false
+arm_version = 7
+arm_arch = "armv7-a"
+
+# Pulse deprecated on Pi
+use_pulseaudio = false
+
+is_component_ffmpeg = true
+# tcmalloc doesn't like armv6 by default
+use_allocator = "none"
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
Index: chromium-browser-65.0.3325.181/pi-util/dodiff.py
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/dodiff.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python
+
+import os, sys, string, subprocess
+
+# Local
+import gitscan, pipaths
+
+def doscan(outfile = sys.stdout):
+    revdict = gitscan.revdict()
+
+    cpath = gitscan.basepath()
+
+    for p in pipaths.pipaths:
+        os.chdir(os.path.join(cpath, p))
+        diff = subprocess.check_output(["git", "diff", revdict[p]])
+
+        header = False
+        lines = diff.split("\n")
+        # Remove terminal blank line
+        if lines[-1] == "":
+            lines.pop()
+        for line in lines:
+            if line.startswith("diff --git "):
+                header = True
+            if header:
+                line = string.replace(line, " a/", " a/" + p + "/")
+                line = string.replace(line, " b/", " b/" + p + "/")
+            if line.startswith("+++ "):
+                header = False
+            print >> outfile, line
+
+
+if __name__ == '__main__':
+    doscan()
+
Index: chromium-browser-65.0.3325.181/pi-util/gitscan.py
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/gitscan.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python
+
+import os, string, subprocess, sys
+
+# Local
+import pipaths
+
+def revdict():
+    revdict = {'src':pipaths.src_commit}
+    stuff = subprocess.check_output(["gclient", "revinfo"])
+    for line in stuff.split("\n"):
+        pathn = line.find(":")
+        commitn = line.rfind("@")
+        if pathn != -1 and commitn != -1 :
+             revdict[line[:pathn]] = line[commitn+1:]
+    return revdict
+
+def basepath():
+    cpath = os.getcwd()
+    if not cpath.endswith("/src"):
+        raise "CWD doesn't end with /src"
+
+    return cpath[:-4]
+
+def gitscan(args, nosrc = False, quiet=False):
+    rv = 0
+
+    oldcwd = os.getcwd()
+    rdict = revdict()
+    cpath = basepath()
+
+    for p in pipaths.pipaths:
+        if nosrc and p == "src":
+            continue
+
+        os.chdir(os.path.join(cpath, p))
+
+        gitargs = [string.replace(string.replace(a, "{PATH}", p), "{BASE}", rdict[p]) for a in args]
+        gitargs[0:0] = ["git"]
+
+        if not quiet:
+            print ">>>", p
+
+        rv = subprocess.call(gitargs)
+        if rv != 0:
+            if not quiet:
+                print "Git returned non-zero error code", rv, "\ncwd =", os.getcwd(), "\ncmd =", gitargs
+            break
+
+    os.chdir(oldcwd)
+    return rv
+
+
+if __name__ == '__main__':
+
+    if len(sys.argv) < 2:
+        print "Usage: gitscan [--gitscan-no-src] <git cmd>"
+        print "  substitutes {PATH} and {BASE}"
+        exit(0)
+
+    nosrc = False
+
+    if sys.argv[1] == "--gitscan-no-src":
+        nosrc = True
+        del sys.argv[1]
+
+    gitscan(sys.argv[1:], nosrc)
+
+
Index: chromium-browser-65.0.3325.181/pi-util/gngen.py
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/gngen.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python
+
+import os, ast, fileinput, subprocess, sys
+
+def docopy(name, vars):
+
+    dest_dir = os.path.join("out", name)
+    src_file = os.path.join("pi-util", "defargs_" + name + ".gn")
+
+    # Ignore any errors making dir (in particular it already exists)
+    try:
+        os.makedirs(dest_dir)
+    except:
+        pass
+
+    dargs = open(os.path.join(dest_dir, "args.gn"), "wt")
+    dargs.write('# -- copied from: ' + src_file + '\n')
+
+    for line in fileinput.input(src_file):
+        dargs.write(line)
+
+    dargs.write('# -- created by ' + sys.argv[0] + '\n')
+    dargs.write('target_sysroot = "' + vars["target_sysroot"] + '"\n')
+    dargs.write('google_api_key = "' + vars["google_api_key"] + '"\n')
+    dargs.write('google_default_client_id = "' + vars["google_default_client_id"] + '"\n')
+    dargs.write('google_default_client_secret = "' + vars["google_default_client_secret"] + '"\n')
+
+    dargs.close()
+
+    subprocess.check_call(["gn", "gen", dest_dir])
+
+
+if __name__ == '__main__':
+    gyp_vars = {}
+    gypi = os.path.join(os.environ["HOME"], ".gyp", "include.gypi")
+    if os.path.isfile(gypi):
+        print "Importing from:", gypi
+        gyps = open(gypi).read(-1)
+        gyp_vars = ast.literal_eval(gyps)["variables"]
+
+    gyp_vars["target_sysroot"] = os.path.abspath("build/linux/raspian_stretch_pi1-sysroot")
+
+    docopy("armv6", gyp_vars)
+    docopy("armv7", gyp_vars)
+
+
+
Index: chromium-browser-65.0.3325.181/pi-util/pi-install-dev.sh
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/pi-install-dev.sh
@@ -0,0 +1,39 @@
+# Install set to build appropriate root on a clean pi
+
+sudo apt-get install \
+comerr-dev \
+libasound2-dev \
+libatk1.0-dev \
+libcap-dev \
+libcups2-dev \
+libexif-dev \
+libffi-dev \
+libgconf2-dev \
+libgl1-mesa-dev \
+libgnome-keyring-dev \
+gtk+-3.0 \
+libjpeg-dev \
+libkrb5-dev \
+libnspr4-dev \
+libnss3-dev \
+libpam0g-dev \
+libpango1.0-dev \
+libpci-dev \
+libpcre3-dev \
+libssl-dev \
+libudev-dev \
+libxcb1-dev \
+libxcb-shm0-dev \
+libxss-dev \
+libxt-dev \
+libxtst-dev \
+mesa-common-dev
+
+# Pulse (hopefully) disabled
+# libpulse-dev \
+
+# Obviously replace paths appropriately below
+# Now run pi-util/syncroot.sh on the compile m/c to grab the appropriate
+# bits of the root and fix up the paths.
+# e.g. ON COMPILE M/C in src dir:
+# pi-util/syncroot.sh my-pi: raspian_jessie_pi1
Index: chromium-browser-65.0.3325.181/pi-util/pipaths.py
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/pipaths.py
@@ -0,0 +1,11 @@
+pipaths=[
+    "src",
+    "src/native_client",
+    "src/third_party/ffmpeg",
+    "src/third_party/libjpeg_turbo",
+    "src/third_party/libyuv",
+    "src/third_party/pdfium",
+    "src/third_party/skia"]
+
+# Our base tag or commit no
+src_commit="65.0.3325.212"
Index: chromium-browser-65.0.3325.181/pi-util/rebase_liblinks.py
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/rebase_liblinks.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python
+
+import os, sys
+from stat import *
+
+def walktree(top, callback, n, prefix):
+    '''recursively descend the directory tree rooted at top,
+       calling the callback function for each regular file'''
+
+    for f in os.listdir(top):
+        pathname = os.path.join(top, f)
+        mode = os.lstat(pathname).st_mode
+        if S_ISDIR(mode):
+            # It's a directory, recurse into it
+            walktree(pathname, callback, n+1, prefix)
+        elif S_ISLNK(mode):
+            # It's a file, call the callback function
+            callback(pathname, os.readlink(pathname), n, prefix)
+
+def visitfile(file, linkname, n, prefix):
+    if (linkname.startswith(prefix + 'lib/')):
+        newlink = "../" * n + linkname[len(prefix):]
+        print 'relinking', file, "->", newlink
+        os.remove(file)
+        os.symlink(newlink, file)
+
+if __name__ == '__main__':
+    argc = len(sys.argv)
+    if argc == 2:
+        walktree(sys.argv[1], visitfile, 0, "/")
+    elif argc == 3:
+        walktree(sys.argv[1], visitfile, 0, sys.argv[2])
+    else:
+        print "rebase_liblinks.py <local root> [<old sysroot>]"
+
+
+
Index: chromium-browser-65.0.3325.181/pi-util/settag.py
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/settag.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+
+import sys, os, subprocess
+
+# Local
+import pipaths
+import gitscan
+import dodiff
+import argparse
+
+def set_version(verstr):
+    pathname = "components/version_info/pi_patch_version_values.h"
+
+    with open(pathname, "wt") as f:
+        f.write("// Pi patch version - generated by pi-util/settag.py\n")
+        f.write('#define PI_PATCH_VERSION_STRING "' + verstr + '"\n')
+
+    subprocess.check_call(["git", "add", pathname])
+    subprocess.check_call(["git", "commit", "-m", "Update pi patch version to " + verstr])
+
+
+def set_tag(verstr):
+    newtag = "pi/" + pipaths.src_commit + "/" + verstr
+    print "Setting tag: " + newtag
+    if gitscan.gitscan(["tag", newtag], quiet=True) != 0:
+        print "Tagging failed"
+        sys.exit(1)
+
+def set_tag_and_version(verstr):
+    set_version(verstr)
+    set_tag(verstr)
+
+if __name__ == '__main__':
+    argp = argparse.ArgumentParser(
+        description="Sets version info in pi_patch_version_values & tags source tree with it")
+    argp.add_argument("-p", action='store_true', help="Generate patch file")
+    argp.add_argument("verstr", help="Pi patch version string")
+    args = argp.parse_args()
+
+    patchpath = os.path.join("..", "v" + pipaths.src_commit + "_" + args.verstr + ".patch")
+
+    if args.p and os.path.exists(patchpath):
+        print "Patchfile", patchpath, "already exists"
+        sys.exit(1)
+
+    print "-- Checking all committed"
+    if gitscan.gitscan(["diff", "--name-status", "--exit-code"], quiet=True) != 0:
+        print "Status check failed - commit everything and try again"
+        sys.exit(1)
+
+    print "-- Generating & committing pi_patch_version_values.h"
+    set_version(args.verstr)
+    print "-- Generating tags"
+    set_tag(args.verstr)
+
+    if args.p:
+        print "-- Generating patch file: ", patchpath
+        with open(patchpath, "wt") as f:
+            dodiff.doscan(f)
+
Index: chromium-browser-65.0.3325.181/pi-util/syncroot.sh
===================================================================
--- /dev/null
+++ chromium-browser-65.0.3325.181/pi-util/syncroot.sh
@@ -0,0 +1,51 @@
+set -e
+
+if [ "$1" == "" ]; then
+  echo Usage: $0 \<src_dir\> [\<rootname\>]
+  echo src_dir is a source for rsync so may contain m/c name.
+  echo rootname will be set to \"raspian_stretch_pi1\" if missing
+  echo e.g.: pi-util/syncroot.sh my-pi: raspian_stretch_pi1
+  exit 1
+fi
+
+SYSROOT_NAME=$2
+if [ "$SYSROOT_NAME" == "" ]; then
+  SYSROOT_NAME=raspian_stretch_pi1
+fi
+
+DST_ROOT=`gclient root`
+DST=$DST_ROOT/src/build/linux/$SYSROOT_NAME-sysroot
+SRC=$1
+
+if [ ! -d $DST_ROOT/src/build/linux ]; then
+  echo We don\'t appear to be in a Chrome build tree
+  exit 1
+fi
+
+echo Sync src:  $SRC
+echo Sync dest: $DST
+
+mkdir -p $DST/lib
+mkdir -p $DST/opt/vc/include
+mkdir -p $DST/usr/lib/pkgconfig
+mkdir -p $DST/usr/bin
+mkdir -p $DST/usr/share
+
+#### MUST NOT include /opt/vc/include/*GL*
+# Creates conflicts with GL includes inside Chrome
+
+rsync -rl $SRC/lib/arm-linux-gnueabihf $DST/lib
+rsync -rl $SRC/opt/vc/lib $DST/opt/vc
+rsync -rl $SRC/opt/vc/include/interface $DST/opt/vc/include
+rsync -rl $SRC/usr/lib/arm-linux-gnueabihf $DST/usr/lib
+rsync -rl $SRC/usr/lib/gcc $DST/usr/lib
+rsync -rl $SRC/usr/include $DST/usr
+rsync -rl $SRC/usr/share/pkgconfig $DST/usr/share
+rsync -rl $SRC/usr/bin/cups-config $DST/usr/bin
+
+cd $DST/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py $DST
+
+
Index: chromium-browser-65.0.3325.181/sandbox/linux/services/proc_util.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/sandbox/linux/services/proc_util.cc
+++ chromium-browser-65.0.3325.181/sandbox/linux/services/proc_util.cc
@@ -17,6 +17,8 @@
 #include "base/posix/eintr_wrapper.h"
 #include "base/strings/string_number_conversions.h"
 
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+
 namespace sandbox {
 namespace {
 
Index: chromium-browser-65.0.3325.181/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc
+++ chromium-browser-65.0.3325.181/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc
@@ -29,6 +29,8 @@ struct local_dma_buf_sync {
 #endif
 
 using sandbox::SyscallSets;
+using sandbox::bpf_dsl::If;
+using sandbox::bpf_dsl::AnyOf;
 using sandbox::bpf_dsl::Allow;
 using sandbox::bpf_dsl::Arg;
 using sandbox::bpf_dsl::Error;
@@ -38,16 +40,20 @@ namespace service_manager {
 
 namespace {
 
+#define ISMAGIC(r, x) (((r) & (_IOC_TYPEMASK << _IOC_TYPESHIFT)) == ((x) << _IOC_TYPESHIFT))
+
 ResultExpr RestrictIoctl() {
   const Arg<unsigned long> request(1);
-  return Switch(request)
+  // Pi - allow all VCHIQ ioctls and the VMCS_SM ioctls
+  return If(AnyOf(ISMAGIC(request, 0xc4), ISMAGIC(request, 'I')), Allow()).Else(
+    Switch(request)
       .SANDBOX_BPF_DSL_CASES((static_cast<unsigned long>(TCGETS), FIONREAD),
                              Allow())
 #if defined(OS_CHROMEOS)
       .SANDBOX_BPF_DSL_CASES(
           (static_cast<unsigned long>(LOCAL_DMA_BUF_IOCTL_SYNC)), Allow())
 #endif
-      .Default(sandbox::CrashSIGSYSIoctl());
+      .Default(sandbox::CrashSIGSYSIoctl()));
 }
 
 }  // namespace
Index: chromium-browser-65.0.3325.181/services/service_manager/sandbox/linux/sandbox_linux.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/service_manager/sandbox/linux/sandbox_linux.h
+++ chromium-browser-65.0.3325.181/services/service_manager/sandbox/linux/sandbox_linux.h
@@ -62,6 +62,7 @@ class SERVICE_MANAGER_SANDBOX_EXPORT San
     METHOD_GET_STYLE_FOR_STRIKE = 35,
     METHOD_MAKE_SHARED_MEMORY_SEGMENT = 36,
     METHOD_MATCH_WITH_FALLBACK = 37,
+    METHOD_OPEN_DEV_VCHIQ,
   };
 
   // These form a bitmask which describes the conditions of the Linux sandbox.
Index: chromium-browser-65.0.3325.181/services/ui/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/ui/BUILD.gn
+++ chromium-browser-65.0.3325.181/services/ui/BUILD.gn
@@ -7,6 +7,7 @@ import("//testing/test.gni")
 import("//services/service_manager/public/cpp/service.gni")
 import("//services/service_manager/public/service_manifest.gni")
 import("//tools/grit/repack.gni")
+import("//build/config/sysroot.gni")
 
 group("all") {
   testonly = true
@@ -34,6 +35,16 @@ service("ui") {
     ":resources_strings",
     "//services/viz",
   ]
+
+  if (current_cpu == "arm" && !is_component_build) {
+    # Add pi link stuff
+    # * is there a better place?
+    ldflags = [
+     "-L$sysroot/opt/vc/lib",
+     "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+     "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+    ]
+  }
 }
 
 service_manifest("manifest") {
Index: chromium-browser-65.0.3325.181/services/viz/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/viz/BUILD.gn
+++ chromium-browser-65.0.3325.181/services/viz/BUILD.gn
@@ -5,6 +5,7 @@
 import("//services/catalog/public/tools/catalog.gni")
 import("//services/service_manager/public/cpp/service.gni")
 import("//services/service_manager/public/service_manifest.gni")
+import("//build/config/sysroot.gni")
 
 service("viz") {
   sources = [
@@ -15,6 +16,16 @@ service("viz") {
     "//services/service_manager/public/cpp",
     "//skia",
   ]
+
+  if (current_cpu == "arm" && !is_component_build) {
+    # Add pi link stuff
+    # * is there a better place?
+    ldflags = [
+     "-L$sysroot/opt/vc/lib",
+     "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+     "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+    ]
+  }
 }
 
 source_set("lib") {
Index: chromium-browser-65.0.3325.181/services/viz/public/cpp/compositing/transferable_resource_struct_traits.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/viz/public/cpp/compositing/transferable_resource_struct_traits.cc
+++ chromium-browser-65.0.3325.181/services/viz/public/cpp/compositing/transferable_resource_struct_traits.cc
@@ -27,6 +27,7 @@ bool StructTraits<viz::mojom::Transferab
   out->format = static_cast<viz::ResourceFormat>(data.format());
   out->buffer_format = static_cast<gfx::BufferFormat>(data.buffer_format());
   out->filter = data.filter();
+  out->stride = data.stride();
   out->read_lock_fences_enabled = data.read_lock_fences_enabled();
   out->is_software = data.is_software();
   out->shared_bitmap_sequence_number = data.shared_bitmap_sequence_number();
Index: chromium-browser-65.0.3325.181/services/viz/public/cpp/compositing/transferable_resource_struct_traits.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/viz/public/cpp/compositing/transferable_resource_struct_traits.h
+++ chromium-browser-65.0.3325.181/services/viz/public/cpp/compositing/transferable_resource_struct_traits.h
@@ -33,6 +33,10 @@ struct StructTraits<viz::mojom::Transfer
     return resource.filter;
   }
 
+  static uint32_t stride(const viz::TransferableResource& resource) {
+    return resource.stride;
+  }
+
   static gfx::Size size(const viz::TransferableResource& resource) {
     return resource.size;
   }
Index: chromium-browser-65.0.3325.181/services/viz/public/interfaces/compositing/shared_bitmap_allocation_notifier.mojom
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/viz/public/interfaces/compositing/shared_bitmap_allocation_notifier.mojom
+++ chromium-browser-65.0.3325.181/services/viz/public/interfaces/compositing/shared_bitmap_allocation_notifier.mojom
@@ -10,7 +10,7 @@ import "gpu/ipc/common/mailbox.mojom";
 // display compositor.
 interface SharedBitmapAllocationNotifier {
   // Informs the display compositor that the child allocated a shared bitmap.
-  DidAllocateSharedBitmap(handle<shared_buffer> buffer, gpu.mojom.Mailbox id);
+  DidAllocateSharedBitmap(handle<shared_buffer> buffer, gpu.mojom.Mailbox id, bool is_image);
 
   // Informs the display compositor that the child deleted a shared bitmap.
   DidDeleteSharedBitmap(gpu.mojom.Mailbox id);
Index: chromium-browser-65.0.3325.181/services/viz/public/interfaces/compositing/transferable_resource.mojom
===================================================================
--- chromium-browser-65.0.3325.181.orig/services/viz/public/interfaces/compositing/transferable_resource.mojom
+++ chromium-browser-65.0.3325.181/services/viz/public/interfaces/compositing/transferable_resource.mojom
@@ -25,6 +25,7 @@ struct TransferableResource {
   ResourceFormat format;
   gfx.mojom.BufferFormat buffer_format;
   uint32 filter;
+  uint32 stride;
   gfx.mojom.Size size;
   gpu.mojom.MailboxHolder mailbox_holder;
   bool read_lock_fences_enabled;
Index: chromium-browser-65.0.3325.181/skia/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/skia/BUILD.gn
+++ chromium-browser-65.0.3325.181/skia/BUILD.gn
@@ -549,6 +549,26 @@ if (current_cpu == "arm64") {
     ]
   }
 }
+if (current_cpu == "arm" && arm_optionally_use_neon && !arm_use_neon)
+{
+  source_set("skia_opts_neon") {
+    check_includes = false
+    sources = skia_opts.neon_sources
+    # Root build config sets -mfpu=$arm_fpu, which we expect to be neon
+    # when running this.
+    configs -= [ "//build/config/compiler:compiler_arm_fpu" ]
+    cflags = [ "-mfpu=neon" ]
+    visibility = [ ":skia_opts" ]
+    configs -= [ "//build/config/compiler:chromium_code" ]
+    configs += [
+      ":skia_config",
+      ":skia_library_config",
+      "//build/config/compiler:no_chromium_code",
+      "//build/config/compiler:force_march_armv7",
+    ]
+  }
+}
+
 if (current_cpu == "x86" || current_cpu == "x64") {
   source_set("skia_opts_sse3") {
     check_includes = false
@@ -688,6 +708,9 @@ source_set("skia_opts") {
           cflags += [ "-mfpu=neon" ]
         }
       }
+    } else if (arm_optionally_use_neon) {
+      deps += [ ":skia_opts_neon" ]
+      sources = skia_opts.none_sources
     } else {
       sources = skia_opts.none_sources
     }
Index: chromium-browser-65.0.3325.181/third_party/WebKit/Source/platform/wtf/CPU.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/WebKit/Source/platform/wtf/CPU.h
+++ chromium-browser-65.0.3325.181/third_party/WebKit/Source/platform/wtf/CPU.h
@@ -36,6 +36,74 @@
 #error Chromium does not support middle endian architecture
 #endif
 
+// RPI added
+/* Set WTF_ARM_ARCH_VERSION */
+#if defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__) || \
+    defined(__MARM_ARMV4__)
+#define WTF_ARM_ARCH_VERSION 4
+
+#elif defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) || \
+    defined(__MARM_ARMV5__)
+#define WTF_ARM_ARCH_VERSION 5
+
+#elif defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) || \
+    defined(__ARM_ARCH_5TEJ__)
+#define WTF_ARM_ARCH_VERSION 5
+
+#elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) ||  \
+    defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) ||   \
+    defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6KZ__) || defined(__ARM_ARCH_6T2__) || \
+    defined(__ARMV6__)
+#define WTF_ARM_ARCH_VERSION 6
+
+#elif defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || \
+    defined(__ARM_ARCH_7S__)
+#define WTF_ARM_ARCH_VERSION 7
+
+/* MSVC sets _M_ARM */
+#elif defined(_M_ARM)
+#define WTF_ARM_ARCH_VERSION _M_ARM
+#else
+#define WTF_ARM_ARCH_VERSION 0
+
+#endif
+
+/* Set WTF_THUMB_ARCH_VERSION */
+#if defined(__ARM_ARCH_4T__)
+#define WTF_THUMB_ARCH_VERSION 1
+
+#elif defined(__ARM_ARCH_5T__) || defined(__ARM_ARCH_5TE__) || \
+    defined(__ARM_ARCH_5TEJ__)
+#define WTF_THUMB_ARCH_VERSION 2
+
+#elif defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || \
+    defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) ||  \
+    defined(__ARM_ARCH_6M__)
+#define WTF_THUMB_ARCH_VERSION 3
+
+#elif defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_7__) || \
+    defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7M__) ||   \
+    defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7S__)
+#define WTF_THUMB_ARCH_VERSION 4
+
+#else
+#define WTF_THUMB_ARCH_VERSION 0
+#endif
+
+#define WTF_ARM_ARCH_AT_LEAST(n) ((n) >= (WTF_THUMB_ARCH_VERSION))
+
+/* CPU(ARM_THUMB2) - Thumb2 instruction set is available */
+#if !defined(WTF_CPU_ARM_THUMB2)
+#if defined(thumb2) || defined(__thumb2__) || \
+    ((defined(__thumb) || defined(__thumb__)) && WTF_THUMB_ARCH_VERSION == 4)
+#define WTF_CPU_ARM_THUMB2 1
+#elif WTF_ARM_ARCH_AT_LEAST(4)
+#define WTF_CPU_ARM_THUMB2 0
+#else
+#error "Unsupported ARM architecture"
+#endif
+#endif /* !defined(WTF_CPU_ARM_THUMB2) */
+
 // WTF_CPU_ARM_NEON is 0 or 1, and should not use defined(WTF_CPU_ARM_NEON).
 #if defined(__ARM_NEON__) && !defined(WTF_CPU_ARM_NEON)
 #define WTF_CPU_ARM_NEON 1
Index: chromium-browser-65.0.3325.181/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
+++ chromium-browser-65.0.3325.181/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
@@ -15,9 +15,8 @@
 .code	32
 #endif
 
-#if defined(__thumb2__) || defined(__clang__)
+@ #if defined(__thumb2__) || defined(__clang__)
 #define ldrhsb	ldrbhs
-#endif
 
 .align	5
 .Lsigma:
Index: chromium-browser-65.0.3325.181/third_party/leveldatabase/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/leveldatabase/BUILD.gn
+++ chromium-browser-65.0.3325.181/third_party/leveldatabase/BUILD.gn
@@ -176,6 +176,10 @@ static_library("leveldb") {
       cflags += [ "/wd4717" ]
     }
   }
+  else
+  {
+    cflags = [ "-Wno-deprecated-declarations" ]
+  }
 }
 
 if (!is_ios && !is_android) {
Index: chromium-browser-65.0.3325.181/third_party/libdrm/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/libdrm/BUILD.gn
+++ chromium-browser-65.0.3325.181/third_party/libdrm/BUILD.gn
@@ -23,7 +23,7 @@ if (!use_system_libdrm) {
       "src/include/drm",
     ]
     if (is_clang) {
-      cflags = [ "-Wno-enum-conversion" ]
+      cflags = [ "-Wno-enum-conversion", "-Wno-deprecated-declarations" ]
     }
   }
 
Index: chromium-browser-65.0.3325.181/third_party/libwebp/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/libwebp/BUILD.gn
+++ chromium-browser-65.0.3325.181/third_party/libwebp/BUILD.gn
@@ -28,8 +28,11 @@ set_opt_level =
 # webp's dsp code can be built for all configurations. Skipping it when both
 # arm_use_neon and arm_optionally_use_neon are false will result in link errors
 # for its dsp init functions.
+#optionally_use_dsp_neon = true
 use_dsp_neon =
-    current_cpu == "arm64" || (current_cpu == "arm" && arm_version >= 7)
+    current_cpu == "arm64" || (current_cpu == "arm" && arm_version >= 6 &&
+                               (arm_use_neon || arm_optionally_use_neon))
+#    current_cpu == "arm64" || (current_cpu == "arm" && (arm_version >= 7 || optionally_use_dsp_neon))
 
 source_set("libwebp_webp") {
   sources = [
@@ -116,6 +119,8 @@ static_library("libwebp_mux") {
 }
 
 static_library("libwebp_dsp") {
+  defines = []
+
   sources = [
     "src/dsp/alpha_processing.c",
     "src/dsp/alpha_processing_mips_dsp_r2.c",
@@ -189,6 +194,14 @@ static_library("libwebp_dsp") {
       "WEBP_HAVE_SSE41",
     ]
   }
+  if (use_dsp_neon) {
+    if (arm_version < 7) {
+      defines += [ "WEBP_HAVE_NEON" ]
+    }
+    if (arm_optionally_use_neon) {
+      defines += [ "WEBP_HAVE_NEON_RTCD" ]
+    }
+  }
 }
 
 static_library("libwebp_dsp_sse41") {
@@ -272,6 +285,11 @@ if (use_dsp_neon) {
       # behavior similar to *.c.neon in an Android.mk
       configs -= [ "//build/config/compiler:compiler_arm_fpu" ]
       cflags = [ "-mfpu=neon" ]
+      if (arm_version < 7) {
+        configs += [
+          "//build/config/compiler:force_march_armv7",
+        ]
+      }
     } else if (current_cpu == "arm64" && !is_clang) {
       # avoid an ICE with gcc-4.9: b/15574841
       cflags = [ "-frename-registers" ]
Index: chromium-browser-65.0.3325.181/third_party/libwebp/src/dsp/cpu.c
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/libwebp/src/dsp/cpu.c
+++ chromium-browser-65.0.3325.181/third_party/libwebp/src/dsp/cpu.c
@@ -180,11 +180,18 @@ static int AndroidCPUInfo(CPUFeature fea
 }
 VP8CPUInfo VP8GetCPUInfo = AndroidCPUInfo;
 #elif defined(WEBP_USE_NEON)
+#if defined(__linux__) && defined(WEBP_HAVE_NEON_RTCD)
+#include <sys/auxv.h>
+#endif
+
 // define a dummy function to enable turning off NEON at runtime by setting
 // VP8DecGetCPUInfo = NULL
 static int armCPUInfo(CPUFeature feature) {
   if (feature != kNEON) return 0;
 #if defined(__linux__) && defined(WEBP_HAVE_NEON_RTCD)
+#if 1
+  return (getauxval(AT_HWCAP) & HWCAP_ARM_NEON) != 0;
+#else
   {
     int has_neon = 0;
     char line[200];
@@ -201,6 +208,7 @@ static int armCPUInfo(CPUFeature feature
     fclose(cpuinfo);
     return has_neon;
   }
+#endif
 #else
   return 1;
 #endif
Index: chromium-browser-65.0.3325.181/third_party/tcmalloc/chromium/src/base/arm_instruction_set_select.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/tcmalloc/chromium/src/base/arm_instruction_set_select.h
+++ chromium-browser-65.0.3325.181/third_party/tcmalloc/chromium/src/base/arm_instruction_set_select.h
@@ -52,6 +52,7 @@
     defined(__ARM_ARCH_6K__) || \
     defined(__ARM_ARCH_6Z__) || \
     defined(__ARM_ARCH_6T2__) || \
+    defined(__ARM_ARCH_6KZ__) || \
     defined(__ARM_ARCH_6ZK__)
 # define ARMV6 1
 #endif
Index: chromium-browser-65.0.3325.181/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
+++ chromium-browser-65.0.3325.181/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
@@ -46,7 +46,11 @@
 // The LDREXD and STREXD instructions in ARM all v7 variants or above.  In v6,
 // only some variants support it.  For simplicity, we only use exclusive
 // 64-bit load/store in V7 or above.
-#if defined(ARMV7)
+#if defined(ARMV7) ||\
+    defined(__ARM_ARCH_6K__) || \
+    defined(__ARM_ARCH_6Z__) || \
+    defined(__ARM_ARCH_6KZ__) || \
+    defined(__ARM_ARCH_6ZK__)
 # define BASE_ATOMICOPS_HAS_LDREXD_AND_STREXD
 #endif
 
@@ -112,7 +116,13 @@ inline Atomic32 NoBarrier_AtomicIncremen
 }
 
 inline void MemoryBarrier() {
+#if ARMV7
   __asm__ __volatile__("dmb" : : : "memory");
+#else
+  // DMB = ,5; DSB = ,4
+  __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
+                        : : "r" (0) : "memory");
+#endif
 }
 
 inline Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
Index: chromium-browser-65.0.3325.181/native_client/src/include/concurrency_ops.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/native_client/src/include/concurrency_ops.h
+++ chromium-browser-65.0.3325.181/native_client/src/include/concurrency_ops.h
@@ -33,13 +33,13 @@ static INLINE void NaClWriteMemoryBarrie
 
 static INLINE void NaClWriteMemoryBarrier(void) {
   /* Note that this depends on ARMv7. */
+#if __ARM_ARCH >= 7
   __asm__ __volatile__("dsb");
-
-  /*
-   * We could support ARMv6 by instead using:
-   * __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
-   *                      : : "r" (0) : "memory");
-   */
+#else
+// DSB = 4, DMB = 5
+  __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 4"
+                        : : "r" (0) : "memory");
+#endif
 }
 
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_mips
Index: chromium-browser-65.0.3325.181/third_party/ffmpeg/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/ffmpeg/BUILD.gn
+++ chromium-browser-65.0.3325.181/third_party/ffmpeg/BUILD.gn
@@ -390,6 +390,8 @@ if (is_component_ffmpeg) {
     deps = [
       ":ffmpeg_internal",
     ]
+    output_name = "ffmpeg_chrome"
+    output_extension = "so.65"
 
     # So we can append below and assume they're defined.
     ldflags = []
Index: chromium-browser-65.0.3325.181/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
+++ chromium-browser-65.0.3325.181/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
@@ -40,7 +40,7 @@
 #define ARCH_X86_64 0
 #define HAVE_ARMV5TE 1
 #define HAVE_ARMV6 1
-#define HAVE_ARMV6T2 1
+#define HAVE_ARMV6T2 0
 #define HAVE_ARMV8 0
 #define HAVE_NEON 0
 #define HAVE_VFP 1
@@ -85,7 +85,7 @@
 #define HAVE_MMI 0
 #define HAVE_ARMV5TE_EXTERNAL 1
 #define HAVE_ARMV6_EXTERNAL 1
-#define HAVE_ARMV6T2_EXTERNAL 1
+#define HAVE_ARMV6T2_EXTERNAL 0
 #define HAVE_ARMV8_EXTERNAL 0
 #define HAVE_NEON_EXTERNAL 0
 #define HAVE_VFP_EXTERNAL 1
@@ -130,7 +130,7 @@
 #define HAVE_MMI_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 1
 #define HAVE_ARMV6_INLINE 1
-#define HAVE_ARMV6T2_INLINE 1
+#define HAVE_ARMV6T2_INLINE 0
 #define HAVE_ARMV8_INLINE 0
 #define HAVE_NEON_INLINE 0
 #define HAVE_VFP_INLINE 1
@@ -555,7 +555,8 @@
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 1
-#define CONFIG_THUMB 1
+#define CONFIG_RAISE_MAJOR 0
+#define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
 #define CONFIG_BSFS 1
Index: chromium-browser-65.0.3325.181/third_party/libjpeg_turbo/simd/jsimd_arm.c
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/libjpeg_turbo/simd/jsimd_arm.c
+++ chromium-browser-65.0.3325.181/third_party/libjpeg_turbo/simd/jsimd_arm.c
@@ -33,6 +33,7 @@ static unsigned int simd_huffman = 1;
 
 #define SOMEWHAT_SANE_PROC_CPUINFO_SIZE_LIMIT (1024 * 1024)
 
+#if !defined(__linux__)
 LOCAL(int)
 check_feature (char *buffer, char *feature)
 {
@@ -89,6 +90,20 @@ parse_proc_cpuinfo (int bufsize)
   return 1;
 }
 
+#else
+#include <sys/auxv.h>
+#include <stdio.h>
+
+static int parse_proc_cpuinfo (int bufsize)
+{
+  const unsigned long auxval = getauxval(AT_HWCAP);
+
+  // Documentation suggests that getauxval(AT_HWCAP) should return a pointer
+  // to a bit array, but evidence suggests it returns a simple bit field
+  simd_support = (auxval & HWCAP_ARM_NEON) != 0 ? JSIMD_ARM_NEON : 0;
+  return 1;
+}
+#endif  // SK_BUILD_FOR_ANDROID
 #endif
 
 /*
Index: chromium-browser-65.0.3325.181/third_party/libyuv/BUILD.gn
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/libyuv/BUILD.gn
+++ chromium-browser-65.0.3325.181/third_party/libyuv/BUILD.gn
@@ -147,6 +147,11 @@ static_library("libyuv_internal") {
     deps += [ "//third_party:jpeg_includes" ]
   }
 
+  if (current_cpu == "arm" && arm_version < 7) {
+    # This emables the neon test even if the current compile doesn't support it
+    defines += [ "LIBYUV_NEON" ]
+  }
+
   if (libyuv_use_neon) {
     deps += [ ":libyuv_neon" ]
   }
@@ -202,6 +207,11 @@ if (libyuv_use_neon) {
 
     if (current_cpu != "arm64") {
       configs -= [ "//build/config/compiler:compiler_arm_fpu" ]
+      if (arm_version < 7) {
+        configs += [
+          "//build/config/compiler:force_march_armv7",
+        ]
+      }
       cflags = [ "-mfpu=neon" ]
     }
   }
Index: chromium-browser-65.0.3325.181/third_party/libyuv/source/cpu_id.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/libyuv/source/cpu_id.cc
+++ chromium-browser-65.0.3325.181/third_party/libyuv/source/cpu_id.cc
@@ -139,6 +139,18 @@ int GetXCR0() {
 #pragma optimize("g", on)
 #endif
 
+#ifdef __ARMEL__
+// This is (a) simpler and (b) works in sandbox vs the /proc/cpuinfo method
+#include <sys/auxv.h>
+
+int ArmCpuCaps(const char* cpuinfo_name) {
+  const unsigned long auxval = getauxval(AT_HWCAP);
+
+  // Documentation suggests that getauxval(AT_HWCAP) should return a pointer
+  // to a bit array, but evidence suggests it returns a simple bit field
+  return ((auxval & HWCAP_ARM_NEON) != 0 ? kCpuHasNEON : 0);
+}
+#else
 // based on libvpx arm_cpudetect.c
 // For Arm, but public to allow testing on any CPU
 LIBYUV_API SAFEBUFFERS int ArmCpuCaps(const char* cpuinfo_name) {
@@ -167,6 +179,7 @@ LIBYUV_API SAFEBUFFERS int ArmCpuCaps(co
   fclose(f);
   return 0;
 }
+#endif
 
 // TODO(fbarchard): Consider read_msa_ir().
 // TODO(fbarchard): Add unittest.
Index: chromium-browser-65.0.3325.181/third_party/pdfium/third_party/base/allocator/partition_allocator/spin_lock.cc
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/pdfium/third_party/base/allocator/partition_allocator/spin_lock.cc
+++ chromium-browser-65.0.3325.181/third_party/pdfium/third_party/base/allocator/partition_allocator/spin_lock.cc
@@ -26,8 +26,14 @@
 #elif defined(COMPILER_GCC) || defined(__clang__)
 #if defined(ARCH_CPU_X86_64) || defined(ARCH_CPU_X86)
 #define YIELD_PROCESSOR __asm__ __volatile__("pause")
-#elif (defined(ARCH_CPU_ARMEL) && __ARM_ARCH >= 6) || defined(ARCH_CPU_ARM64)
+#elif defined(ARCH_CPU_ARMEL) || defined(ARCH_CPU_ARM64)
+#if __ARM_ARCH >= 7 ||\
+  defined(__ARM_ARCH_6KZ__) || defined(__ARM_ARCH_6ZK__) ||\
+  defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6K__)
 #define YIELD_PROCESSOR __asm__ __volatile__("yield")
+#else
+#define YIELD_PROCESSOR __asm__ __volatile__("nop")
+#endif
 #elif defined(ARCH_CPU_MIPSEL)
 // The MIPS32 docs state that the PAUSE instruction is a no-op on older
 // architectures (first added in MIPS32r2). To avoid assembler errors when
Index: chromium-browser-65.0.3325.181/third_party/skia/src/core/SkBitmapProcState.cpp
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/skia/src/core/SkBitmapProcState.cpp
+++ chromium-browser-65.0.3325.181/third_party/skia/src/core/SkBitmapProcState.cpp
@@ -17,7 +17,7 @@
 #include "SkImageEncoder.h"
 #include "SkResourceCache.h"
 
-#if defined(SK_ARM_HAS_NEON)
+#if defined(SK_ARM_HAS_NEON) || defined(SK_ARM_HAS_OPTIONAL_NEON)
 // These are defined in src/opts/SkBitmapProcState_arm_neon.cpp
 extern const SkBitmapProcState::SampleProc32 gSkBitmapProcStateSample32_neon[];
 #endif
Index: chromium-browser-65.0.3325.181/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
+++ chromium-browser-65.0.3325.181/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
@@ -46,7 +46,7 @@ void decal_filter_scale(uint32_t dst[],
 ///////////////////////////////////////////////////////////////////////////////
 
 // Compile neon code paths if needed
-#if defined(SK_ARM_HAS_NEON)
+#if defined(SK_ARM_HAS_NEON) || defined(SK_ARM_HAS_OPTIONAL_NEON)
 
 // These are defined in src/opts/SkBitmapProcState_matrixProcs_neon.cpp
 extern const SkBitmapProcState::MatrixProc ClampX_ClampY_Procs_neon[];
Index: chromium-browser-65.0.3325.181/third_party/skia/src/core/SkUtilsArm.h
===================================================================
--- chromium-browser-65.0.3325.181.orig/third_party/skia/src/core/SkUtilsArm.h
+++ chromium-browser-65.0.3325.181/third_party/skia/src/core/SkUtilsArm.h
@@ -12,6 +12,9 @@
 
 #if defined(SK_ARM_HAS_NEON)
     #define SK_ARM_NEON_WRAP(x) (x ## _neon)
+#elif defined(SK_ARM_HAS_OPTIONAL_NEON)
+    #include "SkCpu.h"
+    #define SK_ARM_NEON_WRAP(x) (SkCpu::Supports(SkCpu::NEON) ? (x ## _neon) : (x))
 #else
     #define SK_ARM_NEON_WRAP(x) (x)
 #endif
